<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Java面试宝典 | SnowIce's Hexo Blog</title><meta name="author" content="SnowIce"><meta name="copyright" content="SnowIce"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="JDK,JRE,JVM 三者关系？  JDK 是 JAVA 程序开发时用的开发工具包，其内部也有 JRE 运行环境 JRE。  JRE 是 JAVA 程序运行时需要的运行环境，就是说如果你光是运行 JAVA 程序而不是去搞开发的话，只安装 JRE 就能运行已经存在的 JAVA 程序了。  JDk、JRE 内部都包含 JAVA 虚拟机 JVM，JAVA 虚拟机内部包含许多应用程序的类的解释器和类加载">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试宝典">
<meta property="og:url" content="https://blog.skypixel.eu.org/2023/04/06/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/index.html">
<meta property="og:site_name" content="SnowIce&#39;s Hexo Blog">
<meta property="og:description" content="JDK,JRE,JVM 三者关系？  JDK 是 JAVA 程序开发时用的开发工具包，其内部也有 JRE 运行环境 JRE。  JRE 是 JAVA 程序运行时需要的运行环境，就是说如果你光是运行 JAVA 程序而不是去搞开发的话，只安装 JRE 就能运行已经存在的 JAVA 程序了。  JDk、JRE 内部都包含 JAVA 虚拟机 JVM，JAVA 虚拟机内部包含许多应用程序的类的解释器和类加载">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://snowice.fun/wp-content/uploads/2023/03/R-C-1-1.jpg">
<meta property="article:published_time" content="2023-04-06T12:26:00.000Z">
<meta property="article:modified_time" content="2023-04-06T12:26:44.035Z">
<meta property="article:author" content="SnowIce">
<meta property="article:tag" content="测试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://snowice.fun/wp-content/uploads/2023/03/R-C-1-1.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.skypixel.eu.org/2023/04/06/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java面试宝典',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-06 20:26:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.snowice.fun/bg-image/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-music"></i><span> 电影</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-video"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://snowice.fun/wp-content/uploads/2023/03/R-C-1-1.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="SnowIce's Hexo Blog"><span class="site-name">SnowIce's Hexo Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-music"></i><span> 电影</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-video"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java面试宝典</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-06T12:26:00.000Z" title="发表于 2023-04-06 20:26:00">2023-04-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-06T12:26:44.035Z" title="更新于 2023-04-06 20:26:44">2023-04-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">25k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>80分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java面试宝典"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="JDK-JRE-JVM-三者关系？"><a href="#JDK-JRE-JVM-三者关系？" class="headerlink" title="JDK,JRE,JVM 三者关系？"></a>JDK,JRE,JVM 三者关系？</h3><ol>
<li> JDK 是 JAVA 程序开发时用的开发工具包，其内部也有 JRE 运行环境 JRE。</li>
<li> JRE 是 JAVA 程序运行时需要的运行环境，就是说如果你光是运行 JAVA 程序而不是去搞开发的话，只安装 JRE 就能运行已经存在的 JAVA 程序了。</li>
<li> JDk、JRE 内部都包含 JAVA 虚拟机 JVM，JAVA 虚拟机内部包含许多应用程序的类的解释器和类加载器等等。</li>
</ol>
<h3 id="面向过程和面向对象的区别？"><a href="#面向过程和面向对象的区别？" class="headerlink" title="面向过程和面向对象的区别？"></a>面向过程和面向对象的区别？</h3><ol>
<li> 两者都是软件开发思想，先有面向过程，后有面向对象。在大型项目中，针对面向过程的不足推出了面向对象开发思想。</li>
<li> 编程思路不同：面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。</li>
<li> 封装性：都具有封装性，但是面向过程是封装的是功能，而面向对象封装的是数据和功能。面向对象具有继承性和多态性， 而面向过程没有继承性和多态 性，所以面向对象优势是明显。</li>
</ol>
<h3 id="Java-有哪些基本数据类型？"><a href="#Java-有哪些基本数据类型？" class="headerlink" title="Java 有哪些基本数据类型？"></a>Java 有哪些基本数据类型？</h3><p>定义：Java 语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p>
<ul>
<li>  数值型：整数类型 (byte,short,int,long)</li>
<li>  数值型：浮点类型 (float,double)</li>
<li>  字符型 (char)</li>
<li>  布尔型 (boolean)</li>
</ul>
<h3 id="什么-Java-注释？"><a href="#什么-Java-注释？" class="headerlink" title="什么 Java 注释？"></a>什么 Java 注释？</h3><ol>
<li> 定义：用于解释说明程序的</li>
<li>文字分类：<ul>
<li>  单行注释：格式： // 注释文字多</li>
<li>  行注释：格式： /* 注释文字 */</li>
<li>  文档注释：格式：/** 注释文字 */</li>
</ul>
</li>
<li> 作用：在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。</li>
</ol>
<p>注意事项：多行和文档注释都不能嵌套使用。</p>
<h3 id="数组和集合有什么区别？"><a href="#数组和集合有什么区别？" class="headerlink" title="数组和集合有什么区别？"></a>数组和集合有什么区别？</h3><ol>
<li> 数组的长度是固定的，集合的长度是可变的。</li>
<li> 数组中存储的是一种类型的元素，可以存储任意类型数据。</li>
<li> 集合存储的都是引用数据类型，如果想存储基本类型数据需要存储对应的包装类型。</li>
</ol>
<h3 id="final-有什么用？"><a href="#final-有什么用？" class="headerlink" title="final 有什么用？"></a>final 有什么用？</h3><p>用于修饰类、属性和方法；</p>
<ol>
<li> 被 final 修饰的类不可以被继承</li>
<li> 被 final 修饰的方法不可以被重写</li>
<li> 被 final 修饰的变量不可以被改变，被 final 修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li>
</ol>
<h3 id="final-fially-finalize-区别"><a href="#final-fially-finalize-区别" class="headerlink" title="final fially finalize 区别"></a>final fially finalize 区别</h3><ol>
<li> final 可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li>
<li> finally 一般作用在 try-catch 代码块中，在处理异常的时候，通常我们将一定要执行的代码方法放在 finally 代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li>
<li> finalize 是一个方法，属于 Object 类的一个方法，而 Object 类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用 System.gc () 方法的时候，由垃圾回收器调用 finalize ()，回收垃圾，一个对象是否可回收的最后判断。</li>
</ol>
<h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><ol>
<li> 封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</li>
<li> 继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。</li>
<li> 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</li>
</ol>
<h3 id="和-equals-的区别是什么？"><a href="#和-equals-的区别是什么？" class="headerlink" title="== 和 equals 的区别是什么？"></a>== 和 equals 的区别是什么？</h3><ol>
<li> == : 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</li>
<li>equals () : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：<ul>
<li>  情况 1：类没有覆盖 equals () 方法。则通过 equals () 比较该类的两个对象时，等价于通过 “==” 比较这两个对象。</li>
<li>  情况 2：类覆盖了 equals () 方法。一般，我们都覆盖 equals () 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li>
</ul>
</li>
</ol>
<h3 id="String-类的常用方法都有那些？"><a href="#String-类的常用方法都有那些？" class="headerlink" title="String 类的常用方法都有那些？"></a>String 类的常用方法都有那些？</h3><ol>
<li> <code>indexOf()</code>：返回指定字符的索引。</li>
<li> <code>charAt()</code>：返回指定索引处的字符。</li>
<li> <code>replace()</code>：字符串替换。</li>
<li> <code>trim()</code>：去除字符串两端空白。</li>
<li> <code>split()</code>：分割字符串，返回一个分割后的字符串数组。</li>
<li> <code>getBytes()</code>：返回字符串的 byte 类型数组。</li>
<li> <code>length()</code>：返回字符串长度。</li>
<li> <code>toLowerCase()</code>：将字符串转成小写字母。</li>
<li> <code>toUpperCase()</code>：将字符串转成大写字符。</li>
<li> <code>substring()</code>：截取字符串。</li>
<li> <code>equals()</code>：字符串比较。</li>
</ol>
<h3 id="String-和-StringBuffer、StringBuilder-的区别是什么？String-为什么是不可变的？"><a href="#String-和-StringBuffer、StringBuilder-的区别是什么？String-为什么是不可变的？" class="headerlink" title="String 和 StringBuffer、StringBuilder 的区别是什么？String 为什么是不可变的？"></a>String 和 StringBuffer、StringBuilder 的区别是什么？String 为什么是不可变的？</h3><p>StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p>对于三者使用的总结：如果要操作少量的数据用 = String，单线程操作字符串缓冲区 下操作大量数据 = StringBuilder，多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</p>
<p>ChatGPT 的回答：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.snowice.fun/blog-image/java/javamsbd/java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B801.png"></p>
<h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><ol>
<li> 装箱：将基本类型用它们对应的引用类型包装起来；</li>
<li> 拆箱：将包装类型转换为基本数据类型；</li>
</ol>
<h3 id="int-和-Integer-有什么区别？"><a href="#int-和-Integer-有什么区别？" class="headerlink" title="int 和 Integer 有什么区别？"></a>int 和 Integer 有什么区别？</h3><p>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱 / 拆箱机制，使得二者可以相互转换。</p>
<h3 id="Java-为每个原始类型提供了哪些包装类型？"><a href="#Java-为每个原始类型提供了哪些包装类型？" class="headerlink" title="Java 为每个原始类型提供了哪些包装类型？"></a>Java 为每个原始类型提供了哪些包装类型？</h3><ul>
<li>  原始类型: <code>boolean</code>，<code>char</code>，<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>float</code>，<code>double</code></li>
<li>  包装类型：<code>Boolean</code>，<code>Character</code>，<code>Byte</code>，<code>Short</code>，<code>Integer</code>，<code>Long</code>，<code>Float</code>，<code>Double</code></li>
</ul>
<h3 id="ArrayList、LinkedList、Vector-的区别？"><a href="#ArrayList、LinkedList、Vector-的区别？" class="headerlink" title="ArrayList、LinkedList、Vector 的区别？"></a>ArrayList、LinkedList、Vector 的区别？</h3><ol>
<li> ArrayList,Vector 底层是由数组实现，LinkedList 底层是由双线链表实现，从底层的实现可以得出它们的性能问题。</li>
<li> ArrayList,Vector 插入速度相对较慢，查询速度相对较快，而 LinkedList 插入速度较快，而查询速度较慢。再者由于 Vevtor 使用了线程安全锁，所以 ArrayList 的运行效率高于 Vector。</li>
</ol>
<h3 id="HashMap-和-Hashtable-的区别？"><a href="#HashMap-和-Hashtable-的区别？" class="headerlink" title="HashMap 和 Hashtable 的区别？"></a>HashMap 和 Hashtable 的区别？</h3><ol>
<li> 线程是否安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li>
<li> 效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>
<li> 对 Null key 和 Null value 的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个</li>
<li> 初始容量大小和每次扩充容量大小的不同 ： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。②创建时如果给定了 容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小</li>
<li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链<br> 表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<h3 id="Synchronized-用过吗，其原理是什么？"><a href="#Synchronized-用过吗，其原理是什么？" class="headerlink" title="Synchronized 用过吗，其原理是什么？"></a>Synchronized 用过吗，其原理是什么？</h3><ol>
<li> Synchronized 是由 JVM 实现的一种实现互斥同步的一种方式，如果你查看被 Synchronized 修饰过的程序块编译后的字节码，会发现被 Synchronized 修饰过的程 序块，在编译前后被编译器生成了 monitorenter 和 monitorexit 两个字节码指令。</li>
<li> 这两个指令是什么意思呢？当虚拟机执行到 monitorenter 指令时，首先要尝试获取对象的锁：如果这个对象没有被其他线程锁定，或者当前线程已经拥有了这个对象的锁，那么就将锁的计数器加 1。当执行 monitorexit 指令时，需要释放对象的锁，将锁计数器减 1。</li>
<li> 如果获取对象的锁失败，当前线程就会被阻塞等待，直到对象的锁被另外一个线程释放为止。在 Java 中，使用 synchronized 关键字来实现同步操作，它通过在对象头部设置标记来达到获取锁和释放锁的目的。</li>
</ol>
<h3 id="为什么说-Synchronized-是非公平锁？"><a href="#为什么说-Synchronized-是非公平锁？" class="headerlink" title="为什么说 Synchronized 是非公平锁？"></a>为什么说 Synchronized 是非公平锁？</h3><p>非公平锁的主要表现在获取锁的行为上，它并不按照申请锁的时间前后给等待线程分配锁，而是每当锁被释放后，任何一个线程都有机会竞争到锁。这样做的目的是为了提高执行性能，但缺点是可能会产生线程饥饿现象。</p>
<h3 id="为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？"><a href="#为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？" class="headerlink" title="为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？"></a>为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？</h3><ol>
<li> Synchronized 显然是一个悲观锁，因为它的并发策略是悲观的：不管是否会产生竞争，任何的数据操作都必须要加锁、用户态和核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。</li>
<li> 随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略。先进行操作，如果没有其他线程征用数据，那操作就成功了；如果共享数据被征用，产生了冲突，那就再进行其他的补偿措施。这种乐观的并发策略的许多实现不需要线程挂起，所以被称为非阻塞同步。</li>
<li> 乐观锁的核心算法是 CAS（Compare and Swap，比较并交换），它涉及到三个操作数：内存值、期望值、新值。当且仅当期望值和内存值相等时才将内存值修改为新值。这样处理的逻辑是，首先检查某块内存的值是否跟之前我读取时的一样。如果不一样，则表示期间此内存值已经被其他线程更改过，舍弃本次操作；否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存。</li>
<li> CAS 具有原子性，它的原子性由 CPU 硬件指令实现保证，即使用 JNI 调用 Native 方法调用由 C++ 编写的硬件级别指令，JDK 中提供了 Unsafe 类执行这些操作</li>
</ol>
<h3 id="乐观锁一定就是好的吗？"><a href="#乐观锁一定就是好的吗？" class="headerlink" title="乐观锁一定就是好的吗？"></a>乐观锁一定就是好的吗？</h3><p>乐观锁避免了悲观锁独占对象的现象，同时也提高了并发性能，但它也有缺点：</p>
<ol>
<li> 乐观锁只能保证一个共享变量的原子操作。如果多一个或几个变量，乐观锁将变得力不从心，但互斥锁能轻易解决，不管对象数量多少及对象颗粒度大小。</li>
<li> 长时间自旋可能导致开销大。假如 CAS 长时间不成功而一直自旋，会给 CPU 带来很大的开销。</li>
<li> ABA 问题。CAS 的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不严谨。假如内存值原来是 A，后来被一条线程改为 B，最后又被改成了 A，则 CAS 认为此内存值并没有发生改变，但实际上是有被其他线程改过的。这种情况对依赖过程值的场景的运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一。</li>
</ol>
<h2 id="JDBC-技术"><a href="#JDBC-技术" class="headerlink" title="JDBC 技术"></a>JDBC 技术</h2><h3 id="什么是-JDBC，在什么时候会用到它？"><a href="#什么是-JDBC，在什么时候会用到它？" class="headerlink" title="什么是 JDBC，在什么时候会用到它？"></a>什么是 JDBC，在什么时候会用到它？</h3><p>JDBC 的全称是 Java Database Connection，也就是 Java 数据库连接，我们可以用它来操作关系型数据库。JDBC 接口及相关类在 java.sql 包和 javax.sql 包里。我们可以用它来连接数据库，执行 SQL 查询，存储过程，并处理返回的结果。JDBC 接口让 Java 程序和 JDBC 驱动实现了松耦合，使得切换不同的数据库变得更加简单。</p>
<h3 id="JDBC-访问数据库的基本步骤是什么？"><a href="#JDBC-访问数据库的基本步骤是什么？" class="headerlink" title="JDBC 访问数据库的基本步骤是什么？"></a>JDBC 访问数据库的基本步骤是什么？</h3><ol>
<li> 加载（注册）数据库驱动（到 JVM）</li>
<li> 建立（获取）数据库连接。</li>
<li> 创建（获取）数据库操作对象。</li>
<li> 定义操作的 SQL 语句。</li>
<li> 执行数据库操作。</li>
<li> 获取并操作结果集。</li>
<li> 关闭对象，回收数据库资源（关闭结果集–&gt; 关闭数据库操作对象–&gt; 关闭连接）</li>
</ol>
<h3 id="execute-executeQuery-executeUpdate-的区别是什么？"><a href="#execute-executeQuery-executeUpdate-的区别是什么？" class="headerlink" title="execute, executeQuery, executeUpdate 的区别是什么？"></a>execute, executeQuery, executeUpdate 的区别是什么？</h3><ol>
<li> Statement 的 execute (String query) 方法用于执行任意的 SQL 查询。如果查询的结果是一个 ResultSet，则该方法返回 true。如果结果不是 ResultSet，例如 insert 或者 update 查询，则该方法返回 false。</li>
<li> Statement 的 executeQuery (String query) 接口用来执行 select 查询，并且返回 ResultSet。即使查询不到记录返回的 ResultSet 也不会为 null。我们通常使用 executeQuery 来执行查询语句，这样的话如果传进来的是 insert 或者 update 语句的话，它会抛出错误信息为 “executeQuery method can not be used for update” 的 java.util.SQLException。</li>
<li> Statement 的 executeUpdate (String query) 方法用于执行 insert、update 或 delete（DML）语句。</li>
<li> 只有当你不确定是什么语句的时候才应该使用 execute () 方法，否则应该使用 executeQuery 或者 executeUpdate 方法。</li>
</ol>
<h3 id="JDBC-的-PreparedStatement-是什么？"><a href="#JDBC-的-PreparedStatement-是什么？" class="headerlink" title="JDBC 的 PreparedStatement 是什么？"></a>JDBC 的 PreparedStatement 是什么？</h3><p>PreparedStatement 对象代表的是一个预编译的 SQL 语句。通过它提供的 setter 方法，可以传入查询的变量。由于 PreparedStatement 是预编译的，可以高效地多次执行对应的 SQL 语句。PreparedStatement 还自动对特殊字符进行转义，避免了 SQL 注入攻击，因此应该尽可能地使用它。</p>
<h3 id="相对于-Statement，PreparedStatement-的优点是什么？"><a href="#相对于-Statement，PreparedStatement-的优点是什么？" class="headerlink" title="相对于 Statement，PreparedStatement 的优点是什么？"></a>相对于 Statement，PreparedStatement 的优点是什么？</h3><ol>
<li> PreparedStatement 有助于防止 SQL 注入，因为它会自动对特殊字符转义。</li>
<li> PreparedStatement 可以用来进行动态查询。</li>
<li> PreparedStatement 执行更快。尤其当你重用它或者使用它的拼量查询接口执行多条语句时。</li>
<li> 使用 PreparedStatement 的 setter 方法更容易编写面向对象的代码，而使用 Statement 则需要拼接字符串来生成查询语句。如果参数过多，字符串拼接看起来会很丑陋，而且容易出错。</li>
</ol>
<h3 id="JDBC-的-ResultSet-是什么？"><a href="#JDBC-的-ResultSet-是什么？" class="headerlink" title="JDBC 的 ResultSet 是什么？"></a>JDBC 的 ResultSet 是什么？</h3><p>在查询数据库后，会返回一个 ResultSet 对象，它就像是查询结果集的一张数据表。ResultSet 对象维护了一个游标，指向当前的数据行。开始时，游标指向第一行。如果调用 ResultSet 的 next () 方法，游标会下移一行，如果没有更多的数据，next () 方法会返回 false。可以在 for 循环中使用它来遍历数据集。</p>
<h3 id="java-util-Date-和-java-sql-Date-有什么区别？"><a href="#java-util-Date-和-java-sql-Date-有什么区别？" class="headerlink" title="java.util.Date 和 java.sql.Date 有什么区别？"></a>java.util.Date 和 java.sql.Date 有什么区别？</h3><p>java.util.Date 包含日期和时间信息，而 java.sql.Date 只包含日期信息，没有具体的时间信息。如果你想在数据库中存储时间信息，可以考虑使用 Timestamp 或者 DateTime 字段。</p>
<h3 id="说说事务的概念，在-JDBC-编程中处理事务的步骤？"><a href="#说说事务的概念，在-JDBC-编程中处理事务的步骤？" class="headerlink" title="说说事务的概念，在 JDBC 编程中处理事务的步骤？"></a>说说事务的概念，在 JDBC 编程中处理事务的步骤？</h3><p>事务是作为单个逻辑工作单元执行的一系列操作。一个逻辑工作单元必须有四个属性，称为原子性、一致性、隔离性和持久性 (ACID) 属性，只有这样才能成为一个事务。JDBC 处理事务有如下操作：</p>
<ul>
<li>  conn.setAutoCommit (false); 设置提交方式为手动提交。</li>
<li>  conn.commit (); 提交事务。</li>
<li>  conn.rollback (); 回滚操作。</li>
</ul>
<p>提交与回滚只选择一个执行。正常情况下，提交事务。如果出现异常，则回滚。</p>
<h3 id="数据库连接池的原理。为什么要使用连接池？"><a href="#数据库连接池的原理。为什么要使用连接池？" class="headerlink" title="数据库连接池的原理。为什么要使用连接池？"></a>数据库连接池的原理。为什么要使用连接池？</h3><ol>
<li> 数据库连接是一种关键的、有限的、昂贵的资源。对数据库连接的管理能显著影响整个应用程序的伸缩性和健壮性，进而影响程序的性能指标。数据库连接池正是为解决这个问题而提出的。</li>
<li> 数据库连接池负责分配、管理和释放数据库连接。它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。同时，它也会释放空闲时间超过最大空闲时间的数据库连接，以避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术可以明显提高对数据库操作的性能。</li>
<li> 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数。当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</li>
</ol>
<h3 id="什么是-JDBC-的最佳实践？"><a href="#什么是-JDBC-的最佳实践？" class="headerlink" title="什么是 JDBC 的最佳实践？"></a>什么是 JDBC 的最佳实践？</h3><ol>
<li> 数据库资源是非常昂贵的，用完了应该尽快关闭它。Connection、Statement、ResultSet 等 JDBC 对象都有 close 方法，调用它就好了。</li>
<li> 养成在代码中显式关闭掉 ResultSet、Statement、Connection 的习惯。如果你用的是连接池的话，连接用完后会放回池里，但是没有关闭的 ResultSet 和 Statement 就会造成资源泄漏。</li>
<li> 在 finally 块中关闭资源，保证即便出了异常也能正常关闭。</li>
<li> 尽量使用 PreparedStatement 而不是 Statement，以避免 SQL 注入，同时还能通过预编译和缓存机制提升执行的效率。</li>
<li> 数据库隔离级别越高性能越差，确保你的数据库连接设置的隔离级别是最优的。</li>
<li> 如果在 WEB 程序中创建数据库连接，最好通过 JNDI 使用 JDBC 的数据源，这样可以对连接进行重用。</li>
</ol>
<h2 id="MySQL-数据库技术"><a href="#MySQL-数据库技术" class="headerlink" title="MySQL 数据库技术"></a>MySQL 数据库技术</h2><h3 id="数据库-MySQL-分页时用的语句"><a href="#数据库-MySQL-分页时用的语句" class="headerlink" title="数据库 MySQL 分页时用的语句"></a>数据库 MySQL 分页时用的语句</h3><p>使用 <code>limit</code> 关键字。<code>Select * from 表名 where 条件 limit 开始位置,结束位置</code>。通过动态的改变开始和结束位置的值来实现分页。</p>
<h3 id="根据你以往的经验简单叙述一下-MySQL-的优化"><a href="#根据你以往的经验简单叙述一下-MySQL-的优化" class="headerlink" title="根据你以往的经验简单叙述一下 MySQL 的优化"></a>根据你以往的经验简单叙述一下 MySQL 的优化</h3><ol>
<li> 尽可能使用更小的整数类型（<code>mediumint</code> 就比 <code>int</code> 更合适）</li>
<li> 如果想要清空表的所有记录，建议用 <code>truncate table tablename</code> 而不是 <code>delete from tablename</code></li>
<li> 尽可能的定义字段为 <code>not null</code>，除非这个字段需要 <code>null</code>。</li>
<li> 避免出现 <code>SELECT * FROM table</code> 语句，要明确查出的字段。</li>
<li> 小心使用 <code>IN</code> 和 <code>OR</code>，需要注意 <code>IN</code> 集合中的数据量。建议集合中的数据不超过 200 个。</li>
</ol>
<h3 id="有两张表；请用-SQL-查询，所有的客户订单日期最新的前五条订单记录。"><a href="#有两张表；请用-SQL-查询，所有的客户订单日期最新的前五条订单记录。" class="headerlink" title="有两张表；请用 SQL 查询，所有的客户订单日期最新的前五条订单记录。"></a>有两张表；请用 SQL 查询，所有的客户订单日期最新的前五条订单记录。</h3><p>客户信息表 (c_CUSTOM) 有以下字段：id、name、mobile</p>
<p>客户订单表 (C_ORDER) 有以下字段: id, custom_id, commodity, count, order_date.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM c_order ORDER BY order_date DESC LIMIT 0,5;</span><br></pre></td></tr></table></figure>

<h3 id="数据库设计中，一对多如何处理？"><a href="#数据库设计中，一对多如何处理？" class="headerlink" title="数据库设计中，一对多如何处理？"></a>数据库设计中，一对多如何处理？</h3><p>数据库外键关系表示的其实是一种一对多关系，所以处理一对多时可以使用外键。</p>
<h3 id="数据库设计中，多对多一般如何处理？"><a href="#数据库设计中，多对多一般如何处理？" class="headerlink" title="数据库设计中，多对多一般如何处理？"></a>数据库设计中，多对多一般如何处理？</h3><p>引入中间表，把一个多对多表示为两个一对多。</p>
<h3 id="MySQL-数据库中，常用的数据类型"><a href="#MySQL-数据库中，常用的数据类型" class="headerlink" title="MySQL 数据库中，常用的数据类型"></a>MySQL 数据库中，常用的数据类型</h3><table width="619"><tbody><tr><td width="132">类型名称</td><td width="423">说明</td></tr><tr><td>int(Integer)</td><td>整数类型</td></tr><tr><td>double</td><td>小数类型</td></tr><tr><td>decimal(m,d)</td><td>指定整数位与小数位长度的小数类型</td></tr><tr><td>date</td><td>日期类型，格式为 yyyy-MM-dd，包含年月日，不包含时分秒</td></tr><tr><td>datetime</td><td>日期类型，格式为 yyyy-MM-dd HH:mm:ss，包含年月日时分秒</td></tr><tr><td>timestamp</td><td>日期类型，时间戳</td></tr><tr><td>varchar(M)</td><td>文本类型，M 为 0~65535 之间的整数</td></tr></tbody></table>

<h3 id="Student-学生表（学号，姓名、性别、年龄、组织部门），Course-课程表（编号，课程名称），Sc-选课表（学号，课程编号，成绩）"><a href="#Student-学生表（学号，姓名、性别、年龄、组织部门），Course-课程表（编号，课程名称），Sc-选课表（学号，课程编号，成绩）" class="headerlink" title="Student 学生表（学号，姓名、性别、年龄、组织部门），Course 课程表（编号，课程名称），Sc 选课表（学号，课程编号，成绩）"></a>Student 学生表（学号，姓名、性别、年龄、组织部门），Course 课程表（编号，课程名称），Sc 选课表（学号，课程编号，成绩）</h3><ul>
<li>  写一个 SQL 语句，查询选修了计算机原理的学生学号和姓名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 学号，姓名 from Student where 学号 in（select 学号 from Sc where 课程编号 in(Select 课程编号 from Course where 课程名称 = ‘计算机原理’)）</span><br></pre></td></tr></table></figure>

<ul>
<li>  写一个 SQL 语句，查询 “周星驰” 同学选修了的课程名字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 课程名称 from Course where 编号 in (select Sc.课程编号 from Student,Sc where Student.姓名=’周星驰’ and Student.学号 = Sc.学号)</span><br></pre></td></tr></table></figure>

<h3 id="表结构说明"><a href="#表结构说明" class="headerlink" title="表结构说明"></a>表结构说明</h3><p>下面是学生表的（Student）的结构说明</p>
<table border="0" width="345" cellspacing="0" cellpadding="0"><tbody><tr><td width="69" height="19">字段名称</td><td width="69">字段解释</td><td width="69">字段类型</td><td width="69">字段长度</td><td width="69">约束</td></tr><tr><td height="19">s_id</td><td>学号</td><td>字符</td><td>10</td><td>PK</td></tr><tr><td height="19">s_name</td><td>学生姓名</td><td>字符</td><td>50</td><td>Not Null</td></tr><tr><td height="19">s_age</td><td>学生年龄</td><td>数值</td><td>3</td><td>Not Null</td></tr><tr><td height="19">s_sex</td><td>学生性别</td><td>字符</td><td>1</td><td>Not Null</td></tr></tbody></table>

<p>下面是教师表（Teacher ）的结构说明</p>
<table border="0" width="345" cellspacing="0" cellpadding="0"><tbody><tr><td width="69" height="19">字段名称</td><td width="69">字段解释</td><td width="69">字段类型</td><td width="69">字段长度</td><td width="69">约束</td></tr><tr><td height="19">t_id</td><td>教师编号</td><td>字符</td><td>10</td><td>PK</td></tr><tr><td height="19">t_name</td><td>教师姓名</td><td>字符</td><td>50</td><td>Not Null</td></tr></tbody></table>

<p>下面是课程表（Course）的结构说明</p>
<table border="0" width="345" cellspacing="0" cellpadding="0"><tbody><tr><td width="69" height="19">字段名称</td><td width="69">字段解释</td><td width="69">字段类型</td><td width="69">字段长度</td><td width="69">约束</td></tr><tr><td height="19">c_id</td><td>课程编号</td><td>字符</td><td>10</td><td>PK</td></tr><tr><td height="19">c_name</td><td>课程名字</td><td>字符</td><td>50</td><td>Not Null</td></tr><tr><td height="19">t_id</td><td>教师编号</td><td>字符</td><td>10</td><td>Not Null</td></tr></tbody></table>

<p>下面是成绩表（SC）的结构说明</p>
<table border="0" width="345" cellspacing="0" cellpadding="0"><tbody><tr><td width="69" height="19">字段名称</td><td width="69">字段解释</td><td width="69">字段类型</td><td width="69">字段长度</td><td width="69">约束</td></tr><tr><td height="19">s_id</td><td>学号</td><td>字符</td><td>10</td><td>PK</td></tr><tr><td height="19">c_id</td><td>课程编号</td><td>字符</td><td>10</td><td>Not Null</td></tr><tr><td height="19">score</td><td>成绩</td><td>数值</td><td>3</td><td>Not Null</td></tr></tbody></table>

<h3 id="查询-“001”-课程比-“002”-课程成绩高的所有学生的学号；"><a href="#查询-“001”-课程比-“002”-课程成绩高的所有学生的学号；" class="headerlink" title="查询 “001” 课程比 “002” 课程成绩高的所有学生的学号；"></a>查询 “001” 课程比 “002” 课程成绩高的所有学生的学号；</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a.s_id from (select s_id,score from SC where C_ID=&#x27;001&#x27;) a,(select s_id,scorefrom SC where C_ID=&#x27;002&#x27;) b where a.score&gt;b.score and a.s_id=b.s_id;</span><br></pre></td></tr></table></figure>

<h3 id="查询平均成绩大于-60-分的同学的学号和平均成绩；"><a href="#查询平均成绩大于-60-分的同学的学号和平均成绩；" class="headerlink" title="查询平均成绩大于 60 分的同学的学号和平均成绩；"></a>查询平均成绩大于 60 分的同学的学号和平均成绩；</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select S_ID,avg(score) from sc group by S_ID having avg(score) &gt;60;</span><br></pre></td></tr></table></figure>

<h3 id="查询所有同学的学号、姓名、选课数、总成绩；"><a href="#查询所有同学的学号、姓名、选课数、总成绩；" class="headerlink" title="查询所有同学的学号、姓名、选课数、总成绩；"></a>查询所有同学的学号、姓名、选课数、总成绩；</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select Student.S_ID,Student.Sname,count(SC.C_ID),sum(score) from Student left Outer join SC on Student.S_ID=SC.S_ID group by Student.S_ID,Sname</span><br></pre></td></tr></table></figure>

<h3 id="查询姓-“李”-的老师的个数；"><a href="#查询姓-“李”-的老师的个数；" class="headerlink" title="查询姓 “李” 的老师的个数；"></a>查询姓 “李” 的老师的个数；</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct(Tname)) from Teacher where Tname like &#x27;李%&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="查询所有课程成绩小于-60-分的同学的学号、姓名；"><a href="#查询所有课程成绩小于-60-分的同学的学号、姓名；" class="headerlink" title="查询所有课程成绩小于 60 分的同学的学号、姓名；"></a>查询所有课程成绩小于 60 分的同学的学号、姓名；</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select S_ID,Sname from Student where S_ID not in (select S.S_ID from Student AS S,SC where S.S_ID=SC.S_ID and score&gt;60);</span><br></pre></td></tr></table></figure>

<h3 id="查询至少有一门课与学号为-“1001”-的同学所学相同的同学的学号和姓名；"><a href="#查询至少有一门课与学号为-“1001”-的同学所学相同的同学的学号和姓名；" class="headerlink" title="查询至少有一门课与学号为 “1001” 的同学所学相同的同学的学号和姓名；"></a>查询至少有一门课与学号为 “1001” 的同学所学相同的同学的学号和姓名；</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct S_ID,Sname from Student,SC where Student.S_ID=SC.S_ID and SC.C_ID in (select C_ID from SC where S_ID=&#x27;1001&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-语言和-jQuery-技术"><a href="#JavaScript-语言和-jQuery-技术" class="headerlink" title="JavaScript 语言和 jQuery 技术"></a>JavaScript 语言和 jQuery 技术</h2><h3 id="JS-中如何将页面重定向到另一个页面？"><a href="#JS-中如何将页面重定向到另一个页面？" class="headerlink" title="JS 中如何将页面重定向到另一个页面？"></a>JS 中如何将页面重定向到另一个页面？</h3><ol>
<li> 使用 location.href：window.location.href =”<a target="_blank" rel="noopener" href="https://www.baidu.com/%E2%80%9D">https://www.baidu.com/”</a></li>
<li> 使用 location.replace：window.location.replace (“<a target="_blank" rel="noopener" href="https://www.baidu.com/;%E2%80%9D">https://www.baidu.com/;”</a>);</li>
</ol>
<h3 id="undefined，null-和-undeclared-有什么区别？"><a href="#undefined，null-和-undeclared-有什么区别？" class="headerlink" title="undefined，null 和 undeclared 有什么区别？"></a>undefined，null 和 undeclared 有什么区别？</h3><ol>
<li> undefined 表示” 缺少值”，就是此处应该有一个值，但是还没有定义，转为数值时为 NaN。典型用法是：变量被声明了，但没有赋值时，就等于 undefined。调用函数时，应该提供的参数没有提供，该参数等于 undefined。对象没有赋值的属性，该属性的值为 undefined。函数没有返回值时，默认返回 undefined。</li>
<li> null 表示” 没有对象”，即该处不应该有值，转为数值时为 0。典型用法是：作为函数的参数，表示该函数的参数不是对象。作为对象原型链的终点。</li>
<li> undeclared：js 语法错误，没有申明直接使用，js 无法找到对应的上下文。</li>
</ol>
<h3 id="如何在-JavaScript-中每-x-秒调用一个函数？"><a href="#如何在-JavaScript-中每-x-秒调用一个函数？" class="headerlink" title="如何在 JavaScript 中每 x 秒调用一个函数？"></a>如何在 JavaScript 中每 x 秒调用一个函数？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInterval(function ()&#123; alert(&quot;Hello&quot;); &#125;, 3000);</span><br></pre></td></tr></table></figure>

<h3 id="JS-中-和-区别是什么？"><a href="#JS-中-和-区别是什么？" class="headerlink" title="JS 中 == 和 === 区别是什么？"></a>JS 中 == 和 === 区别是什么？</h3><ol>
<li> 对于 string,number 等基础类型，== 和 === 有区别：不同类型间比较，== 之比较 “转化成同一类型后的值” 看 “值” 是否相等，=== 如 果类型不同，其结果就是不等。同类型比较，直接进行 “值” 比较，两者结果一样。</li>
<li> 对于 Array,Object 等高级类型，== 和 === 没有区别，进行 “指针地址” 比较。</li>
</ol>
<h3 id="JavaScript-内置可用类型"><a href="#JavaScript-内置可用类型" class="headerlink" title="JavaScript 内置可用类型"></a>JavaScript 内置可用类型</h3><p>string，number，boolean，null 和 undefined，object，symbol（ES6 新语法）</p>
<h3 id="jQuery-库中的-是什么？"><a href="#jQuery-库中的-是什么？" class="headerlink" title="jQuery 库中的 $() 是什么？"></a>jQuery 库中的 $() 是什么？</h3><p>$() 函数是 jQuery () 函数的别称。$() 函数用于将任何对象包裹成 jQuery 对象，接着你就被允许调用定义在 jQuery 对象上的多个不同方法。你可以将一个选择器字符串传入 $() 函数，它会返回一个包含所有匹配的 DOM 元素数组的 jQuery 对象。</p>
<h3 id="jQuery-有几种选择器？"><a href="#jQuery-有几种选择器？" class="headerlink" title="jQuery 有几种选择器？"></a>jQuery 有几种选择器？</h3><ol>
<li> 基本选择器：<code>#id</code>，<code>class</code>,<code>element</code>，<code>*</code>;</li>
<li> 层次选择器：<code>parent &gt; child</code>，<code>prev + next</code> ，<code>prev ~ siblings</code></li>
<li> 基本过滤器选择器：<code>:first</code>，<code>:last</code> ，<code>:not</code> ，<code>:even</code></li>
<li> 表单选择器： <code>:input</code> ，<code>:text</code> ，<code>:password</code> ，<code>:radio</code> ，<code>:checkbox</code> ，<code>:submit</code> 等；</li>
<li> 表单过滤器选择器：<code>:enabled</code> ，<code>:disabled</code> ，<code>:checked</code> ，<code>:selected</code></li>
</ol>
<h3 id="jQuery-中-get-提交和-post-提交有区别吗？"><a href="#jQuery-中-get-提交和-post-提交有区别吗？" class="headerlink" title="jQuery 中 $.get () 提交和 $.post () 提交有区别吗？"></a>jQuery 中 $.get () 提交和 $.post () 提交有区别吗？</h3><p>相同点：都是异步请求的方式来获取服务端的数据；</p>
<p>异同点：</p>
<ul>
<li>  请求方式不同：$.get () 方法使用 GET 方法来进行异步请求的。$.post () 方法使用 POST 方法来进行异步请求的。</li>
<li>  参数传递方式不同：get 请求会将参数跟在 URL 后进行传递，而 POST 请求则是作为 HTTP 消息的实体内容发送给 Web 服务器的，这种传递是对用户不可见的。</li>
<li>  数据传输大小不同：get 方式传输的数据大小不能超过 2KB 而 POST 要大的多</li>
<li>  安全问题： GET 方式请求的数据会被浏览器缓存起来，因此有安全问题。</li>
</ul>
<h3 id="window-onload-函数和-jQuery-中的-document-ready-有什么区别？"><a href="#window-onload-函数和-jQuery-中的-document-ready-有什么区别？" class="headerlink" title="window.onload () 函数和 jQuery 中的 document.ready () 有什么区别？"></a>window.onload () 函数和 jQuery 中的 document.ready () 有什么区别？</h3><ol>
<li> 执行时间：window.onload 必须等到页面内包括图片的所有元素加载完毕后才能执行。$(document).ready () 是 DOM 结构绘制完毕后就执行，不必等到加载完毕。$(document).ready () 在 window.onload 之前执行。</li>
<li> 简化写法：window.onload 没有简化写法。$(document).ready (function (){}) 可以简写成 $(function (){});</li>
<li> 出现地方不同：window.onload 是 js 标准，可出现在任何 js 脚本中。$(document).ready 只有在 jq 库中出现。</li>
</ol>
<h3 id="什么是-CDN？哪些是流行的-jQuery-CDN？使用-CDN-有什么好处？"><a href="#什么是-CDN？哪些是流行的-jQuery-CDN？使用-CDN-有什么好处？" class="headerlink" title="什么是 CDN？哪些是流行的 jQuery CDN？使用 CDN 有什么好处？"></a>什么是 CDN？哪些是流行的 jQuery CDN？使用 CDN 有什么好处？</h3><p>内容传送网络或内容分发网络（CDN）是部署在因特网上的多个数据中心的大型分布式服务器系统。CDN 的目标是为具有高可用性和高性能的最终用户提供内容。</p>
<p>有 3 个流行的 jQuery CDN：谷歌，微软 jQuery。</p>
<p>使用 CDN 的优势：它减少了服务器的负载。它节省了带宽。jQuery 框架将从这些 CDN 加载更快。最重要的好处是，如果用户访<br>问过使用任何这些 CDN 的 jQuery 框架的任何站点，它将被缓存</p>
<h3 id="如何从-CDN-加载-jQuery？"><a href="#如何从-CDN-加载-jQuery？" class="headerlink" title="如何从 CDN 加载 jQuery？"></a>如何从 CDN 加载 jQuery？</h3><p>下面是从 3 个 CDN 加载 jQuery 的代码。</p>
<ul>
<li>  从 Google CDN 加载 jQuery Framework 的代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>  从 Microsoft CDN 加载 jQuery Framework 的代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://ajax.microsoft.com/ajax/jquery/jquery-1.9.1.min.js&quot;&gt; &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>  从 jQuery 站点加载 jQuery Framework 的代码（EdgeCast CDN）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://code.jquery.com/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JSP-技术"><a href="#JSP-技术" class="headerlink" title="JSP 技术"></a>JSP 技术</h2><h3 id="说一说-Servlet-的生命周期？"><a href="#说一说-Servlet-的生命周期？" class="headerlink" title="说一说 Servlet 的生命周期？"></a>说一说 Servlet 的生命周期？</h3><ol>
<li> Servlet 有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由 javax.servlet.Servlet 接口的 init (),service () 和 destroy 方法表达。</li>
<li> Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，service 方法自动派遣运行与请求对应的 do***() 方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其 destroy 方法。</li>
<li> web 容器加载 servlet，生命周期开始。通过调用 servlet 的 init () 方法进行 servlet 的初始化。通过调用 service () 方法实现，根据请求的不同调用不同的 do***() 方法。结束服务，web 容器调用 servlet 的 destroy () 方法。</li>
</ol>
<h3 id="JSP-和-Servlet-的区别、共同点、各自应用的范围？"><a href="#JSP-和-Servlet-的区别、共同点、各自应用的范围？" class="headerlink" title="JSP 和 Servlet 的区别、共同点、各自应用的范围？"></a>JSP 和 Servlet 的区别、共同点、各自应用的范围？</h3><p>JSP 是 Servlet 技术的扩展，本质上就是 Servlet 的简易方式。JSP 编译后是 “类 servlet”。Servlet 和 JSP 最主要的不同点在于：Servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 HTML 里分离开来。而 JSP 的情况是 Java 和 HTML 可以组合成一个扩展名为.jsp 的文件。JSP 侧重于视图，Servlet 主要用于控制逻辑。在 struts 框架中，JSP 位于 MVC 设计模式的视图层，而 Servlet 位于 控制层.</p>
<h3 id="Servlet-API-中-forward-与-redirect-的区别？"><a href="#Servlet-API-中-forward-与-redirect-的区别？" class="headerlink" title="Servlet API 中 forward () 与 redirect () 的区别？"></a>Servlet API 中 forward () 与 redirect () 的区别？</h3><ul>
<li>  从地址栏显示来说</li>
</ul>
<p>forward 是服务器请求资源，服务器直接访问目标地址的 URL, 把那个 URL 的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址. redirect 是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址。所以地址栏显示的是新的 URL. 所以 redirect 等于客 户端向服务器端发出两次 request，同时也接受两次 response。</p>
<ul>
<li>  从数据共享来说</li>
</ul>
<p>forward: 转发页面和转发到的页面可以共享 request 里面的数据.redirect: 不能共享数据.redirect 不仅可以重定向到当前应用程序的其他资源，还可以重定向到同一个站点上的其他应用程序中的资源，甚至是使用绝对 URL 重定向到其他站点的资源.forward 方法 只能在同一个 Web 应用程序内的资源之间转发请求.forward 是服务器内部的一种操作.redirect 是服务器通知客户端，让客户端重新发起请求。所以，你可以说 redirect 是一种间接的请求，但是你不能说” 一个请求是属于 forward 还是 redirect “。</p>
<ul>
<li>  从运用地方来说</li>
</ul>
<p>forward: 一般用于用户登陆的时候，根据角色转发到相应的模块. redirect: 一般用于用户注销登陆时返回主页面和跳转到其它的网站等。</p>
<ul>
<li>  从效率来说</li>
</ul>
<p>forward: 高。</p>
<p>redirect: 低。</p>
<h3 id="request-getAttribute-和-request-getParameter-有何区别？"><a href="#request-getAttribute-和-request-getParameter-有何区别？" class="headerlink" title="request.getAttribute () 和 request.getParameter () 有何区别？"></a>request.getAttribute () 和 request.getParameter () 有何区别？</h3><ol>
<li> request.getParameter () 取得是通过容器的实现来取得通过类似 post，get 等方式传入的数据。</li>
<li> getAttribute 是返回对象，getParameter 返回字符串。</li>
<li> getAttribute () 一向是和 setAttribute () 一起使用的，只有先用 setAttribute () 设置之后，才能够通过 getAttribute () 来获得值，它们传递的是 Object 类型的数据。而且必须在同一个 request 对象中使用才有效。, 而 getParameter () 是接收表单的 get 或者 post 提交过来的参数。</li>
</ol>
<h3 id="MVC-的各个部分都有那些技术来实现？如何实现？"><a href="#MVC-的各个部分都有那些技术来实现？如何实现？" class="headerlink" title="MVC 的各个部分都有那些技术来实现？如何实现？"></a>MVC 的各个部分都有那些技术来实现？如何实现？</h3><p>MVC 是 Model－View－Controller 的简写。Model 代表的是应用的业务逻辑（通过 JavaBean，EJB 组件实现），View 是应用的表示面（由 JSP 页面产生），Controller 是提供应用的处理过程控制（一般是一个 Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。</p>
<h3 id="JSP-有哪些内置对象？作用分别是什么？"><a href="#JSP-有哪些内置对象？作用分别是什么？" class="headerlink" title="JSP 有哪些内置对象？作用分别是什么？"></a>JSP 有哪些内置对象？作用分别是什么？</h3><ol>
<li> request 用户端请求，此请求会包含来自 GET/POST 请求的参数；</li>
<li> response 网页传回用户端的回应；</li>
<li> pageContext 网页的属性是在这里管理；</li>
<li> session 与请求有关的会话期；</li>
<li> application 封装服务器运行环境的对象；</li>
<li> out 输出服务器响应的输出流对象；</li>
<li> config Web 应用的配置对象；</li>
<li> page JSP 网页本身；</li>
<li> exception 封装页面抛出异常的对象。</li>
</ol>
<h3 id="说一下-JSP-的-4-种作用域？"><a href="#说一下-JSP-的-4-种作用域？" class="headerlink" title="说一下 JSP 的 4 种作用域？"></a>说一下 JSP 的 4 种作用域？</h3><ol>
<li> page：代表与一个页面相关的对象和属性。</li>
<li> request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。</li>
<li> session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 Session 中。</li>
<li> application：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</li>
</ol>
<h3 id="Session-和-Cookie-有什么区别？"><a href="#Session-和-Cookie-有什么区别？" class="headerlink" title="Session 和 Cookie 有什么区别？"></a>Session 和 Cookie 有什么区别？</h3><ol>
<li> 存储位置不同：Session 存储在服务器端；Cookie 存储在浏览器端。</li>
<li> 安全性不同：Cookie 安全性一般，在浏览器存储，可以被伪造和修改。</li>
<li> 容量和个数限制：Cookie 有容量限制，每个站点下的 Cookie 也有个数限制。</li>
<li> 存储的多样性：Session 可以存储在 Redis 中、数据库中、应用程序中；而 Cookie 只能存储在浏览器中。</li>
</ol>
<h3 id="说一下-Session-的工作原理？"><a href="#说一下-Session-的工作原理？" class="headerlink" title="说一下 Session 的工作原理？"></a>说一下 Session 的工作原理？</h3><p>Session 的工作原理是客户端登录完成之后，服务器会创建对应的 Session，Session 创建完之后，会把 Session 的 ID 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 Session ID，服务器拿到 Session ID 之后，在内存找到与之对应的 Session 这样就可以正常工作了。</p>
<h3 id="JSP-三大指令是什么？"><a href="#JSP-三大指令是什么？" class="headerlink" title="JSP 三大指令是什么？"></a>JSP 三大指令是什么？</h3><ol>
<li> Page ：指令是针对当前页面的指令；</li>
<li> Include ：用于指定如何包含另一个页面；</li>
<li> Taglib ：用于定义和指定自定义标签。</li>
</ol>
<h3 id="http-的响应码-200，404，302，500-表示的含义分别是？"><a href="#http-的响应码-200，404，302，500-表示的含义分别是？" class="headerlink" title="http 的响应码 200，404，302，500 表示的含义分别是？"></a>http 的响应码 200，404，302，500 表示的含义分别是？</h3><ul>
<li>  200 – 确定。客户端请求已成功</li>
<li>  404 – 未找到文件或目录</li>
<li>  302 – 临时移动转移，请求的内容已临时移动新的位置</li>
<li>  500 – 服务器内部错误</li>
</ul>
<h3 id="如何解决表单提交的中文乱码问题？"><a href="#如何解决表单提交的中文乱码问题？" class="headerlink" title="如何解决表单提交的中文乱码问题？"></a>如何解决表单提交的中文乱码问题？</h3><ul>
<li>  设置页面编码，若是 jsp 页面，需编写代码:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot; contentType=&quot;text/html;charset=UTF-8&quot; %&gt;</span><br></pre></td></tr></table></figure>

<p>若是 html 页面，在网页头部（ <head>&lt; /head&gt; ）中添加下面这段代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>  将 form 表单提交方式变为 post 方式，即添加 <code>method=&quot;post&quot;</code>；在 Servlet 类中编写代码 <code>request.setCharacterEncoding(&quot;UTF-8&quot;)</code>，而且必须写在第一行。</li>
<li>  如果是 get 请求，在 Servlet 类中编写代码 <code>byte [] bytes = str.getBytes(&quot;iso-8859-1&quot;)</code>;<code>String cstr = newString(bytes,&quot;utf-8&quot;)</code>; 或者直接修改 Tomcat 服务器配置文件 server.xml 增加内容：<code>URIEncoding=&quot;utf-8&quot;</code></li>
</ul>
<h3 id="你的项目中使用过哪些-JSTL-标签？"><a href="#你的项目中使用过哪些-JSTL-标签？" class="headerlink" title="你的项目中使用过哪些 JSTL 标签？"></a>你的项目中使用过哪些 JSTL 标签？</h3><p>项目中主要使用了 JSTL 的核心标签库，包括 <code>&lt; c:if&gt;</code>、<code>&lt; c:choose&gt;</code>、<code>&lt; c: when&gt;</code>、<code>&lt; c: otherwise&gt;</code>、<code>&lt; c:forEach&gt;</code> 等，主要用于构造循环和分支结构以控制显示逻辑。虽然 JSTL 标签库提供了 <code>core</code>、<code>sql</code>、<code>fmt</code>、<code>xml</code> 等标签库，但是实际开发中建议只使 用核心标签库（core），而且最好只使用分支和循环标签并辅以表达式语言（EL），这样才能真正做到数据显示和业务逻辑的分离，这才是最佳实践。</p>
<h3 id="怎么防止重复提交？"><a href="#怎么防止重复提交？" class="headerlink" title="怎么防止重复提交？"></a>怎么防止重复提交？</h3><ol>
<li> 禁掉提交按钮。表单提交后使用 Javascript 使提交按钮 disable。这种方法防止心急的用户多次点击按钮。但有个问题，如果客户端把 Javascript 给禁止掉，这种方法就无效了。</li>
<li> Post/Redirect/Get 模式。在提交后执行页面重定向，这就是所谓的 Post-Redirect-Get (PRG) 模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。这能避免用户按 F5 导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退按导致的同样问题。</li>
<li> 在 session 中存放一个特殊标志。当表单页面被请求时，生成一个特殊的字符标志串，存在 session 中，同时放在表单的隐藏域里。接受处理表单数据时，检查标识字串是否存在，并立即从 session 中删除它，然后正常处理数据。如果发现表单提交里没有有效的标志串，这说明表单已经被提交过了，忽略这次提交。</li>
<li> 在数据库里添加约束。在数据库里添加唯一约束或创建唯一索引，防止出现重复数据。这是最有效的防止重复提交数据的方法。</li>
</ol>
<h3 id="Request-对象的主要方法有哪些？"><a href="#Request-对象的主要方法有哪些？" class="headerlink" title="Request 对象的主要方法有哪些？"></a>Request 对象的主要方法有哪些？</h3><table width="1008"><tbody><tr><td width="250">方法</td><td width="527">解释</td></tr><tr><td>setAttribute(String name,Object)</td><td>设置名字为 name 的 request 的参数值</td></tr><tr><td>getAttribute(String name)</td><td>返回由 name 指定的属性值</td></tr><tr><td>getAttributeNames()</td><td>返回 request 对象所有属性的名字集合，结果是一个枚举的实例</td></tr><tr><td>getCookies()</td><td>返回客户端的所有</td></tr><tr><td>getCharacterEncoding()</td><td>返回请求中的字符编码方式 = getContentLength () ：返回请求的 Body 的长度</td></tr><tr><td>getParameter(String name)</td><td>获得客户端传送给服务器端的有 name 指定的参数值</td></tr><tr><td>getRequestURI()</td><td>获取发出请求字符串的客户端地址</td></tr><tr><td>getRemoteAddr()</td><td>获取客户端的 IP 地址</td></tr><tr><td>getRemoteHost()</td><td>获取客户端的名字</td></tr><tr><td>getServletPath()</td><td>获取客户端所请求的脚本文件的路径</td></tr><tr><td>getServerPort()</td><td>获取服务器的端口号</td></tr><tr><td>removeAttribute(String name)</td><td>删除请求中的一个属性</td></tr></tbody></table>

<h3 id="JSP-中动态-include-和静态-include-的区别？"><a href="#JSP-中动态-include-和静态-include-的区别？" class="headerlink" title="JSP 中动态 include 和静态 include 的区别？"></a>JSP 中动态 include 和静态 include 的区别？</h3><ul>
<li>  静态 include：语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ include file=&quot;文件名&quot; %&gt;</span><br></pre></td></tr></table></figure>

<p>相当于复制，编辑时将对应的文件包含进来，当内容变化时，不会再一次对其编译，不易维护。</p>
<ul>
<li>  动态 include：语法：</li>
</ul>
<p>能够自动检查被包含文件，当客户端对 JSP 文件进行请求时，会重新将对应的文件包含进来，进行实时的更新。</p>
<h3 id="什么情况下调用-doGet-和-doPost"><a href="#什么情况下调用-doGet-和-doPost" class="headerlink" title="什么情况下调用 doGet () 和 doPost ()?"></a>什么情况下调用 doGet () 和 doPost ()?</h3><p>默认情况是调用 doGet () 方法，JSP 页面中的 Form 表单的 method 属性设置为 post 的时候，调用的为 doPost () 方法；为 get 的时候，调用 deGet () 方法。</p>
<h3 id="get-和-post-的区别？"><a href="#get-和-post-的区别？" class="headerlink" title="get 和 post 的区别？"></a>get 和 post 的区别？</h3><ol>
<li> get 是用来从服务器上获取数据，而 post 是用来向服务器传递数据；</li>
<li> get 将表单中数据按照 variable=value 的形式，添加到 action 所指向的 URL 后面，并且两者用”？” 连接，变量之间用”&amp;” 连接而 post 是将表单中的数据放在 form 的数据体中，按照变量与值对应的方式，传递到 action 所指定的 URL；</li>
<li> get 是不安全的，因为在传输过程中，数据是被放在请求的 URL 中；而 post 的所有操作对用户来说都是不可见的；</li>
<li> get 传输的数据量小，这主要应为受 url 长度限制；而 post 可以传输大量的数据，所有上传文件只能用 post 提交；</li>
<li> get 限制 form 表单的数据集必须为 ASCII 字符；而 post 支持整个 IS01 0646 字符集；</li>
<li> get 是 form 表单的默认方法。</li>
</ol>
<h2 id="Spring-框架"><a href="#Spring-框架" class="headerlink" title="Spring 框架"></a>Spring 框架</h2><h3 id="什么是-Spring-框架？"><a href="#什么是-Spring-框架？" class="headerlink" title="什么是 Spring 框架？"></a>什么是 Spring 框架？</h3><p>Spring 是一个开放源代码的设计层面框架，它解决的是业务逻辑层和其他各层的松耦合问题，是一个分层的 JavaEE 一站式轻量级开源框架。</p>
<h3 id="Spring-的作用？"><a href="#Spring-的作用？" class="headerlink" title="Spring 的作用？"></a>Spring 的作用？</h3><p>方便解耦，简化开发，AOP 编程支持，声明式事务支持，集成 Junit 更加方便的进行分层测试，方便集成各种优秀框架。</p>
<h3 id="什么是-IOC？"><a href="#什么是-IOC？" class="headerlink" title="什么是 IOC？"></a>什么是 IOC？</h3><p>控制反转，把创建对象的权利交给 Spring。</p>
<h3 id="什么是-DI"><a href="#什么是-DI" class="headerlink" title="什么是 DI?"></a>什么是 DI?</h3><p>属性的依赖注入，Spring 在通过 IOC 创建对象的时候，如果对象还有属性，就一并给赋值进去 DI 是在 IOC 的基础上进行对象的属性注入。</p>
<h3 id="依赖注入的三种实现方式？"><a href="#依赖注入的三种实现方式？" class="headerlink" title="依赖注入的三种实现方式？"></a>依赖注入的三种实现方式？</h3><ol>
<li> 构造器注入</li>
<li> Setter 方法注入</li>
<li> 接口注入</li>
</ol>
<h3 id="解释-Spring-支持的几种-bean-的作用域？"><a href="#解释-Spring-支持的几种-bean-的作用域？" class="headerlink" title="解释 Spring 支持的几种 bean 的作用域？"></a>解释 Spring 支持的几种 bean 的作用域？</h3><ol>
<li> <code>singleton</code>: bean 在每个 Spring IOC 容器中只有一个实例。</li>
<li> <code>prototype</code>：一个 bean 的定义可以有多个实例。</li>
<li> <code>request</code>：每次 http 请求都会创建一个 bean，该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。</li>
<li> <code>session</code>：在一个 HTTP Session 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。</li>
<li> <code>global-session</code>：在一个全局的 HTTP Session 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 SpringApplicationContext 情形下有效。缺省的 Spring bean 的作用域是 Singleton。</li>
</ol>
<h3 id="Spring-支持的事务管理类型？"><a href="#Spring-支持的事务管理类型？" class="headerlink" title="Spring 支持的事务管理类型？"></a>Spring 支持的事务管理类型？</h3><ol>
<li> 编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</li>
<li> 声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和 XML 配置来管理事务。</li>
</ol>
<h3 id="你更倾向用那种事务管理类型？"><a href="#你更倾向用那种事务管理类型？" class="headerlink" title="你更倾向用那种事务管理类型？"></a>你更倾向用那种事务管理类型？</h3><p>大多数 Spring 框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。</p>
<h3 id="解释-AOP"><a href="#解释-AOP" class="headerlink" title="解释 AOP"></a>解释 AOP</h3><p>在软件业，AOP 为 Aspect Oriented Programming 的缩写，意味：面向切面编程。通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术，AOP 是 OOP 的延续。将一些共性的内容进行抽取，在需要用到的地方，以动态代理的方式进行插入。在不修 改源码的基础上，还能对源码进行前后增强。</p>
<h3 id="什么是通知？有哪五种类型的通知？"><a href="#什么是通知？有哪五种类型的通知？" class="headerlink" title="什么是通知？有哪五种类型的通知？"></a>什么是通知？有哪五种类型的通知？</h3><p>通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过 Spring AOP 框架触发的代码段。<br>Spring 切面可以应用五种类型的通知：</p>
<ol>
<li> before：前置通知，在一个方法执行前被调用。</li>
<li> after-returning: 仅当方法成功完成后执行的通知。</li>
<li> after-throwing: 在方法抛出异常退出时执行的通知。</li>
<li> after: 在方法执行之后调用的通知，无论方法执行是否成功。</li>
<li> around: 在方法执行之前和之后调用的通知。</li>
</ol>
<h2 id="Spring-MVC-框架"><a href="#Spring-MVC-框架" class="headerlink" title="Spring MVC 框架"></a>Spring MVC 框架</h2><h3 id="什么是-Spring-MVC？"><a href="#什么是-Spring-MVC？" class="headerlink" title="什么是 Spring MVC？"></a>什么是 Spring MVC？</h3><p>Spring MVC 是 Spring 的一个模块，基于 MVC 的一个框架，无需中间整合层来整合。</p>
<h3 id="Spring-MVC-工作原理？"><a href="#Spring-MVC-工作原理？" class="headerlink" title="Spring MVC 工作原理？"></a>Spring MVC 工作原理？</h3><ol>
<li> 客户端发送请求到 DispatcherServlet；</li>
<li> DispatcherServlet 查询 handlerMapping 找到处理请求的 Controller、Controller 调用业务逻辑后，返回 ModelAndView；</li>
<li> DispatcherServlet 查询 ModelAndView，找到指定视图、视图将结果返回到客户端。</li>
</ol>
<h3 id="Spring-MVC-流程？"><a href="#Spring-MVC-流程？" class="headerlink" title="Spring MVC 流程？"></a>Spring MVC 流程？</h3><ol>
<li> 用户发送请求至前端控制器 DispatcherServlet。</li>
<li> DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。</li>
<li> 处理器映射器找到具体的处理器 (可以根据 XML 配置、注解进行查找)，生成处理器对象及处理器拦截器 (如果有则生成) 一并返回给 DispatcherServlet。</li>
<li> DispatcherServlet 调用 HandlerAdapter 处理器适配器。</li>
<li> HandlerAdapter 经过适配调用具体的处理器 (Controller，也叫后端控制器)。</li>
<li> Controller 执行完成返回 ModelAndView。</li>
<li> HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。h、DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。</li>
<li> ViewReslover 解析后返回具体 View。</li>
<li> DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。</li>
<li> DispatcherServlet 响应用户。</li>
</ol>
<h3 id="如果你也用过-Struts2-简单介绍下-Spring-MVC-和-Struts2-的区别有哪些？"><a href="#如果你也用过-Struts2-简单介绍下-Spring-MVC-和-Struts2-的区别有哪些？" class="headerlink" title="如果你也用过 Struts2. 简单介绍下 Spring MVC 和 Struts2 的区别有哪些？"></a>如果你也用过 Struts2. 简单介绍下 Spring MVC 和 Struts2 的区别有哪些？</h3><ol>
<li> Spring MVC 的入口是一个 Servlet 即前端控制器，而 Struts2 入口是一个 Filter 过虑器。</li>
<li> Spring MVC 是基于方法开发 (一个 URL 对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例 (建议单例)，Struts2 是基于类开发，传递参数是通过类的属性，只能设计为多例。</li>
<li> Struts2 采用值栈存储请求和响应的数据，通过 OGNL 存取数据，Spring MVC 通过参数解析器是将 request 请求内容解析，并给方法形参赋值，将数据和视图封装成 ModelAndView 对象，最后又将 ModelAndView 中的模型数据通过 reques 域传输到页面。JSP 视图解析器默认使用 JSTL。</li>
</ol>
<h3 id="RequestMapping-注解用在类上面有什么作用？"><a href="#RequestMapping-注解用在类上面有什么作用？" class="headerlink" title="@RequestMapping 注解用在类上面有什么作用？"></a>@RequestMapping 注解用在类上面有什么作用？</h3><p>是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<h3 id="Spring-MVC-的控制器是不是单例模式，如果是，有什么问题，怎么解决？"><a href="#Spring-MVC-的控制器是不是单例模式，如果是，有什么问题，怎么解决？" class="headerlink" title="Spring MVC 的控制器是不是单例模式，如果是，有什么问题，怎么解决？"></a>Spring MVC 的控制器是不是单例模式，如果是，有什么问题，怎么解决？</h3><p>是单例模式，所以在多线程访问的时候有线程安全问题，不要用同步，会影响性能的，解决方案是在控制器里面不能写字段。</p>
<h3 id="怎么样在方法里面得到-Request-或者-Session？"><a href="#怎么样在方法里面得到-Request-或者-Session？" class="headerlink" title="怎么样在方法里面得到 Request, 或者 Session？"></a>怎么样在方法里面得到 Request, 或者 Session？</h3><p>直接在方法的形参中声明 Request,Spring MVC 就自动把 Request 对象传入。</p>
<h3 id="如果前台有很多个参数传入，并且这些参数都是一个对象的，那么怎么样快速得到这个对象？"><a href="#如果前台有很多个参数传入，并且这些参数都是一个对象的，那么怎么样快速得到这个对象？" class="headerlink" title="如果前台有很多个参数传入，并且这些参数都是一个对象的，那么怎么样快速得到这个对象？"></a>如果前台有很多个参数传入，并且这些参数都是一个对象的，那么怎么样快速得到这个对象？</h3><p>直接在方法中声明这个对象，Spring MVC 就自动会把属性赋值到这个对象里面。</p>
<h3 id="Spring-MVC-中函数的返回值是什么？"><a href="#Spring-MVC-中函数的返回值是什么？" class="headerlink" title="Spring MVC 中函数的返回值是什么？"></a>Spring MVC 中函数的返回值是什么？</h3><p>返回值可以有很多类型，有 String, ModelAndView, 当一般用 String 比较好。</p>
<h3 id="Spring-MVC-怎么样设定重定向和转发的？"><a href="#Spring-MVC-怎么样设定重定向和转发的？" class="headerlink" title="Spring MVC 怎么样设定重定向和转发的？"></a>Spring MVC 怎么样设定重定向和转发的？</h3><p>在返回值前面加”<code>forward:</code>“就可以让结果转发，譬如”<code>forward:user.do?name=method4</code>” 在返回值前面加”<code>redirect:</code>“就可以让返回值重定向，譬如”<code>redirect:http://www.baidu.com</code>“。</p>
<h3 id="Spring-MVC-怎么和-AJAX-相互调用的？"><a href="#Spring-MVC-怎么和-AJAX-相互调用的？" class="headerlink" title="Spring MVC 怎么和 AJAX 相互调用的？"></a>Spring MVC 怎么和 AJAX 相互调用的？</h3><p>通过 Jackson 框架就可以把 Java 里面的对象直接转化成 Js 可以识别的 Json 对象。</p>
<p>具体步骤如下 ：</p>
<ol>
<li> 加入 Jackson.jar</li>
<li> 在配置文件中配置 Json 的映射</li>
<li> 在接受 AJAX 方法里面可以直接返回 Object,List 等，但方法前面要加上 @ResponseBody</li>
</ol>
<h3 id="如何解决-POST-请求中文乱码问题，GET-的又如何处理呢？"><a href="#如何解决-POST-请求中文乱码问题，GET-的又如何处理呢？" class="headerlink" title="如何解决 POST 请求中文乱码问题，GET 的又如何处理呢？"></a>如何解决 POST 请求中文乱码问题，GET 的又如何处理呢？</h3><p>解决 post 请求乱码问题：在 web.xml 中配置一个 CharacterEncodingFilter 过滤器，设置成 utf-8；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;utf-8&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>get 请求中文参数出现乱码解决方法有两个：</p>
<ul>
<li>  修改 tomcat 配置文件添加编码与工程编码一致，如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ConnectorURIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>  另外一种方法对参数进行重新编码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String userName = new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859- 1&quot;),&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure>

<p>ISO8859-1 是 tomcat 默认编码，需要将 tomcat 编码后的内容按 utf-8 编码。</p>
<h2 id="MyBatis-框架"><a href="#MyBatis-框架" class="headerlink" title="MyBatis 框架"></a>MyBatis 框架</h2><h3 id="什么是-MyBatis？"><a href="#什么是-MyBatis？" class="headerlink" title="什么是 MyBatis？"></a>什么是 MyBatis？</h3><p>MyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架。</p>
<h3 id="MyBatis-动态-SQL-是做什么的？都有哪些动态-SQL？能简述一下动态-SQL-的执行原理不？"><a href="#MyBatis-动态-SQL-是做什么的？都有哪些动态-SQL？能简述一下动态-SQL-的执行原理不？" class="headerlink" title="MyBatis 动态 SQL 是做什么的？都有哪些动态 SQL？能简述一下动态 SQL 的执行原理不？"></a>MyBatis 动态 SQL 是做什么的？都有哪些动态 SQL？能简述一下动态 SQL 的执行原理不？</h3><p>MyBatis 动态 SQL 是为了解决在 SQL 语句中出现条件判断、分页、动态排序等情况，使得 SQL 语句能够更加灵活地生成。MyBatis 的动态 SQL 包括以下几种：</p>
<ol>
<li> if 元素：根据条件判断动态生成 SQL 语句；</li>
<li> choose（when、otherwise）元素：类似于 Java 中的 switch 语句，根据条件选择生成 SQL 语句；</li>
<li> where 元素：用于构建动态查询条件，自动去除查询语句中不必要的 where 或 and 关键字；</li>
<li> set 元素：用于构建动态更新条件；</li>
<li> foreach 元素：用于遍历一个集合，动态生成 SQL 语句。</li>
</ol>
<p>动态 SQL 的执行原理是：MyBatis 在解析 Mapper.xml 文件时，会将动态 SQL 语句解析成一个完整的 SQL 语句，然后再将这个完整的 SQL 语句传递给 JDBC 执行。在解析 Mapper.xml 文件时，MyBatis 使用 OGNL 表达式来进行条件判断和数据遍历等操作，然后根据条件生成相应的 SQL 语句，最终生成一条完整的 SQL 语句，传递给 JDBC 执行。</p>
<h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{} 和 ${} 的区别是什么？"></a>#{} 和 ${} 的区别是什么？</h3><ol>
<li> #{} 是预编译处理，${} 是字符串替换。</li>
<li> MyBatis 在处理 #{} 时，会将 SQL 中的 #{} 替换为？号，调用 PreparedStatement 的 set 方法来赋值。</li>
<li> MyBatis 在处理 ${} 时，就是把 ${} 替换成变量的值。</li>
<li> 使用 #{} 可以有效的防止 SQL 注入，提高系统安全性。</li>
</ol>
<h3 id="为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"></a>为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h3><p>Hibernate 属于全自动 ORM (Object-Relational Mapping) 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 SQL 来完成，所以，称之为半自动 ORM 映射工具。</p>
<h3 id="MyBatis-与-Hibernate-有哪些不同"><a href="#MyBatis-与-Hibernate-有哪些不同" class="headerlink" title="MyBatis 与 Hibernate 有哪些不同"></a>MyBatis 与 Hibernate 有哪些不同</h3><ol>
<li> MyBatis 和 Hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 SQL 语句，不过 MyBatis 可以通过 XML 或注解方式灵活配置要运行的 SQL 语句，并将 Java 对象和 SQL 语句映射生成最终执行的 SQL，最后将 SQL 执行的结果再映射生成 Java 对象。</li>
<li> MyBatis 学习门槛低，简单易学，程序员直接编写原生态 SQL，可严格控制 SQL 执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是 MyBatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套 SQL 映射文件，工作量大。</li>
<li> Hibernate 对象 / 关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用 Hibernate 开发可以节省很多代码，提高效率。但是 Hibernate 的缺点是学习门槛高，要精通门槛更高，而且怎么设计 O/R 映射，在性能和对象模型之间如何权衡，以及怎样用好 Hibernate 需要具有很强的经验和能力才行。总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</li>
</ol>
<h3 id="MyBatis-的好处是什么"><a href="#MyBatis-的好处是什么" class="headerlink" title="MyBatis 的好处是什么"></a>MyBatis 的好处是什么</h3><ol>
<li> MyBatis 把 SQL 语句从 Java 源程序中独立出来，放在单独的 XML 文件中编写，给程序的维护带来了很大便利。</li>
<li> MyBatis 封装了底层 JDBC API 的调用细节，并能自动将结果集转换成 Java Bean 对象， 大大简化了 Java 数据库编程的重复工作。</li>
<li> 因为 MyBatis 需要程序员自己去编写 SQL 语句，程序员可以结合数据库自身的特点灵活控制 SQL 语句，因此能够实现比 Hibernate 等全自动 ORM 框架更高的查询效率，能够完成复杂查询。</li>
</ol>
<h3 id="什么是-MyBatis-的接口绑定，有什么好处？"><a href="#什么是-MyBatis-的接口绑定，有什么好处？" class="headerlink" title="什么是 MyBatis 的接口绑定，有什么好处？"></a>什么是 MyBatis 的接口绑定，有什么好处？</h3><p>接口映射就是在 MyBatis 中任意定义接口，然后把接口里面的方法和 SQL 语句绑定，我们直接调用接口方法就可以，这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置。</p>
<h3 id="接口绑定有几种实现方式，分别是怎么实现的？"><a href="#接口绑定有几种实现方式，分别是怎么实现的？" class="headerlink" title="接口绑定有几种实现方式，分别是怎么实现的？"></a>接口绑定有几种实现方式，分别是怎么实现的？</h3><p>接口绑定有两种实现方式：</p>
<ol>
<li> 通过注解绑定，就是在接口的方法上面加上 @Select@Update 等注解里面包含 SQL 语句来绑定。</li>
<li> 通过 XML 里面写 SQL 来绑定，在这种情况下，要指定 XML 映射文件里面的 namespace 必须为接口的全路径名。</li>
</ol>
<h3 id="当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定-POJO？"><a href="#当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定-POJO？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定 POJO？"></a>当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定 POJO？</h3><ol>
<li> 通过在查询的 SQL 语句中定义字段名的别名。</li>
<li> 通过来映射字段名和实体类属性名的一一对应的关系。</li>
</ol>
<h3 id="Mapper-DAO-层开发规范"><a href="#Mapper-DAO-层开发规范" class="headerlink" title="Mapper DAO 层开发规范"></a>Mapper DAO 层开发规范</h3><ol>
<li> 接口的全路径要和映射文件的 namespace 保持一致。</li>
<li> 接口的方法名要和映射文件中的 statementId 保持一致。</li>
<li> 接口方法的参数类型，返回类型要和映射文件中的 parameterType,resultType 保持一致。</li>
<li> 接口和映射文件的名字最好保持一致 例如：UserMapper.java/UserMapper.xml。</li>
<li> 接口和映射文件最好放到同一个目录。</li>
</ol>
<h2 id="Shiro-安全框架"><a href="#Shiro-安全框架" class="headerlink" title="Shiro 安全框架"></a>Shiro 安全框架</h2><h3 id="Shiro-可以完成哪些工作？"><a href="#Shiro-可以完成哪些工作？" class="headerlink" title="Shiro 可以完成哪些工作？"></a>Shiro 可以完成哪些工作？</h3><p>Shiro 可以帮助我们完成：认证、授权、加密、会话管理、与 Web 集成、缓存等。</p>
<h3 id="Apache-Shiro-的三大核心组件"><a href="#Apache-Shiro-的三大核心组件" class="headerlink" title="Apache Shiro 的三大核心组件"></a>Apache Shiro 的三大核心组件</h3><ol>
<li> Subject ：当前用户的操作。</li>
<li> SecurityManager：用于管理所有的 Subject。</li>
<li> Realms：用于进行权限信息的验证。</li>
</ol>
<h3 id="Shiro-有哪些组件？"><a href="#Shiro-有哪些组件？" class="headerlink" title="Shiro 有哪些组件？"></a>Shiro 有哪些组件？</h3><ol>
<li> Authentication：身份认证 / 登录，验证用户是不是拥有相应的身份。</li>
<li> Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限。</li>
<li> Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 Java SE 环境的，也可以是如 Web 环境的。</li>
<li> Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储。</li>
<li> Web Support：Web 支持，可以非常容易的集成到 Web 环境。</li>
<li> Caching：缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率。</li>
<li> Concurrency：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去。</li>
<li> Testing：提供测试支持。</li>
<li> Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。</li>
<li> Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li>
</ol>
<h3 id="比较-Spring-Security-和-Shiro"><a href="#比较-Spring-Security-和-Shiro" class="headerlink" title="比较 Spring Security 和 Shiro"></a>比较 Spring Security 和 Shiro</h3><p>相比 Spring Security， Shiro 在保持强大功能的同时，使用简单性和灵活性。 SpringSecurity: 即使是一个一个简单的请求，最少得经过它的 8 个 Filter。Spring Security 必须在 Spring 的环境下使用。初学 Spring Security，曲线还是较大，需要深入学习其源码和框架， 配置起来也较费力。</p>
<h3 id="Shiro-的优点"><a href="#Shiro-的优点" class="headerlink" title="Shiro 的优点"></a>Shiro 的优点</h3><ol>
<li> 简单的身份认证，支持多种数据源。</li>
<li> 对角色的简单的授权，支持细粒度的授权 (方法级)。</li>
<li> 支持一级缓存，以提升应用程序的性能。</li>
<li> 内置的基于 POJO 企业会话管理，适用于 Web 以及非 Web 的环境。</li>
<li> 非常简单的加密 API。</li>
<li> 不跟任何的框架或者容器捆绑，可以独立运行。</li>
</ol>
<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h3 id="什么是-Maven？"><a href="#什么是-Maven？" class="headerlink" title="什么是 Maven？"></a>什么是 Maven？</h3><ol>
<li> Maven 使用项目对象模型 (POM) 的概念，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。</li>
<li> Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发布时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。</li>
<li> Maven 的出现，解决了开发过程中的 jar 包升级及依赖的难题。它可以对项目依赖的 jar 包进行管理，可以让你的项目保持基本的依赖，排除冗余 jar 包，并且可以让你非常轻松的对依赖的 jar 包进行版本升级。而这些仅仅是 Maven 最基本的功能，它可以在这基础上对项目进行清理、编译、测试、打包、发布等等构建项目的工作。</li>
<li> 可以说，Maven 是现在 Java 社区中最强大的项目管理和项目构建工具，而更加值得庆幸的是，这样一个强大的工具，它的使用也是非常简单的。现在，JavaEE 项目使用的开源软件都可以通过 Maven 来获取，并且，越来越多的公司也开始使用 Maven 来管理构建项目了。</li>
</ol>
<h3 id="Maven-仓库是什么？"><a href="#Maven-仓库是什么？" class="headerlink" title="Maven 仓库是什么？"></a>Maven 仓库是什么？</h3><p>Maven 仓库是基于简单文件系统存储的，集中化管理 Java API 资源（构件）的一个服务。仓库中的任何一个构件都有其唯一的坐标，根据这个坐标可以定义其在仓库中的唯一存储路径。得益于 Maven 的坐标机制，任何 Maven 项目使用任何一个构件的方式都是完全相同的，Maven 可以在某个位置统一存储所有的 Maven 项目共享的构件，这个统一的位置就是仓库，项目构建完毕后生成的构件也可以安装或者部署到仓库中，供其它项目使用。</p>
<p>对于 Maven 来说，仓库分为两类：</p>
<ul>
<li>  本地仓库</li>
<li>  远程仓库</li>
</ul>
<h3 id="Maven-的工程类型有哪些？"><a href="#Maven-的工程类型有哪些？" class="headerlink" title="Maven 的工程类型有哪些？"></a>Maven 的工程类型有哪些？</h3><ol>
<li> POM 工程：POM 工程是逻辑工程。用在父级工程或聚合工程中。用来做 jar 包的版本控制。</li>
<li> JAR 工程：将会打包成 jar 用作 jar 包使用。即常见的本地工程 – Java Project。</li>
<li> WAR 工程：将会打包成 war，发布在服务器上的工程。如网站或服务。即常见的网络工程 – Dynamic Web Project。WAR 工程默认没有 WEB-INF 目录及 web.xml 配置文件，IDE 通常会显示工程错误，提供完整工程结构可以解决。</li>
</ol>
<h3 id="Maven-常用命令有哪些？"><a href="#Maven-常用命令有哪些？" class="headerlink" title="Maven 常用命令有哪些？"></a>Maven 常用命令有哪些？</h3><ul>
<li>  install</li>
</ul>
<p>本地安装， 包含编译，打包，安装到本地仓库。</p>
<p>编译 – javac。</p>
<p>打包 – jar， 将 java 代码打包为 jar 文件。</p>
<p>安装到本地仓库 – 将打包的 jar 文件，保存到本地仓库目录中。</p>
<ul>
<li>  clean</li>
</ul>
<p>清除已编译信息。<br>删除工程中的 target 目录</p>
<ul>
<li>  compile</li>
</ul>
<p>只编译。 javac 命令。</p>
<ul>
<li>  deploy</li>
</ul>
<p>部署。 常见于结合私服使用的命令。相当于是 install + 上传 jar 到私服。包含编译，打包，安装到本地仓库，上传到私服仓库。</p>
<ul>
<li>  package</li>
</ul>
<p>打包。 包含编译，打包两个功能。</p>
<h2 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h2><h3 id="绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示？切换目录用什么命令？"><a href="#绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示？切换目录用什么命令？" class="headerlink" title="绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示？切换目录用什么命令？"></a>绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示？切换目录用什么命令？</h3><ul>
<li>  绝对路径：如 <code>/etc/init.d</code></li>
<li>  当前目录和上层目录：<code>./</code> <code>../</code></li>
<li>  主目录：<code>~/</code></li>
<li>  切换目录：<code>cd</code></li>
</ul>
<h3 id="怎么查看当前进程？怎么执行退出？怎么查看当前路径？"><a href="#怎么查看当前进程？怎么执行退出？怎么查看当前路径？" class="headerlink" title="怎么查看当前进程？怎么执行退出？怎么查看当前路径？"></a>怎么查看当前进程？怎么执行退出？怎么查看当前路径？</h3><ul>
<li>  查看当前进程：<code>ps</code></li>
<li>  执行退出：<code>exit</code></li>
<li>  查看当前路径：<code>pwd</code></li>
</ul>
<h3 id="怎么清屏？怎么退出当前命令？"><a href="#怎么清屏？怎么退出当前命令？" class="headerlink" title="怎么清屏？怎么退出当前命令？"></a>怎么清屏？怎么退出当前命令？</h3><ul>
<li>  清屏：输入命令 <code>clear</code> 或者使用按键 <code>CTRL</code>+<code>L</code></li>
<li>  退出当前命令：<code>CTRL+C</code> 彻底退出</li>
</ul>
<h3 id="查看文件内容有哪些命令可以使用？"><a href="#查看文件内容有哪些命令可以使用？" class="headerlink" title="查看文件内容有哪些命令可以使用？"></a>查看文件内容有哪些命令可以使用？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi 文件名 <span class="comment"># 编辑方式查看，可修</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 文件名 <span class="comment"># 显示全部文件内</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more 文件名 <span class="comment"># 分页显示文件内容</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less 文件名 <span class="comment"># 与more相似，更好的是可以往前翻页</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> 文件名 <span class="comment"># 仅查看尾部，还可以指定</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> 文件名 <span class="comment"># 仅查看头部,还可以指定</span></span><br></pre></td></tr></table></figure>



<h3 id="复制文件包括其子文件到自定目录"><a href="#复制文件包括其子文件到自定目录" class="headerlink" title="复制文件包括其子文件到自定目录"></a>复制文件包括其子文件到自定目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r sourceFolder targetFolder <span class="comment"># 将名为&quot;sourceFolder&quot;的文件夹及其中的内容复制到名为&quot;targetFolder&quot;的文件夹中</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  “cp” 是”copy” 的缩写，表示复制命令。</li>
<li>  “-r” 是”recursive” 的缩写，表示递归复制，即复制源文件夹及其中的所有子文件夹和文件。</li>
<li>  “sourceFolder” 是要复制的源文件夹的名称。</li>
<li>  “targetFolder” 是目标文件夹的名称，即将源文件夹复制到该目录下。</li>
</ul>
<p>如果目标文件夹不存在，该命令会自动创建一个新的目标文件夹。</p>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> newFloder <span class="comment"># 创建一个名为&quot;newFloder&quot;的新文件夹（或者叫做目录）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  “mkdir” 是”make directory” 的缩写，表示创建目录的命令。</li>
<li>  “newFloder” 是要创建的新文件夹的名称。</li>
</ul>
<p>如果同名的文件夹已经存在，则该命令会返回一个错误。</p>
<h3 id="删除目录（此目录是空目录）"><a href="#删除目录（此目录是空目录）" class="headerlink" title="删除目录（此目录是空目录）"></a>删除目录（此目录是空目录）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> deleteEmptyFolder <span class="comment"># 删除一个空的名为&quot;deleteEmptyFolder&quot;的文件夹（或者叫做目录）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  “rmdir” 是”remove directory” 的缩写，表示删除目录的命令。</li>
<li>  “deleteEmptyFolder” 是要删除的空文件夹的名称。</li>
</ul>
<p>如果这个文件夹不是空的，或者同名的文件或文件夹不存在，则该命令会返回一个错误。需要注意的是，这个命令不能用于删除非空的文件夹，否则也会返回一个错误。</p>
<h3 id="删除文件包括其子文件"><a href="#删除文件包括其子文件" class="headerlink" title="删除文件包括其子文件"></a>删除文件包括其子文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf deleteFile <span class="comment"># 删除名为&quot;deleteFile&quot;的文件或文件夹，包括其中的所有内容，而不进行任何提示或警告。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  “rm” 是”remove” 的缩写，表示删除命令。</li>
<li>  “-rf” 是两个选项的组合，其中”-r” 表示递归删除，即删除目录及其子目录和文件；”-f” 表示强制删除，即无需确认直接删除，不会询问是否确认操作。</li>
<li>  “deleteFile” 是要删除的文件或文件夹的名称。</li>
</ul>
<p>慎用</p>
<p>这个命令将会删除当前工作目录下的一个名为”deleteFile” 的文件或文件夹，包括其中的所有内容，而不进行任何提示或警告。需要非常小心使用该命令，因为它非常强大，一旦误用可能会造成不可逆的损失。</p>
<h3 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf test.tar.gz <span class="comment"># 解压缩名为&quot;test.tar.gz&quot;的压缩文件。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  “tar” 是”tape archive” 的缩写，是一个常用的打包和压缩命令。</li>
<li>  “-z” 选项表示要对压缩文件使用 gzip 算法进行解压缩。</li>
<li>  “-x” 选项表示要解包（解压缩）文件。</li>
<li>  “-v” 选项表示输出详细的信息，即在屏幕上显示所有被解包的文件名。</li>
<li>  “-f” 选项后面跟着的是要解包的文件名，即”test.tar.gz”。</li>
</ul>
<p>这个命令将会解压缩当前目录下的”test.tar.gz” 压缩文件，并将其中的文件提取到当前目录下。其中，”.tar” 表示文件经过 tar 命令打包过，”.gz” 表示文件经过 gzip 命令压缩过。需要注意的是，该命令只能用于解压缩 tar 和 gzip 命令打包和压缩的文件。</p>
<h3 id="解压-zip-文件"><a href="#解压-zip-文件" class="headerlink" title="解压 zip 文件"></a>解压 zip 文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -oq file.zip <span class="comment"># 解压缩名为&quot;file.zip&quot;的zip压缩文件，并且指定不进行任何交互操作和输出过程信息。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  “unzip” 是解压缩命令。</li>
<li>  “-o” 选项表示在解压缩时不进行任何交互操作，即覆盖所有现有文件，不会询问用户是否要覆盖。</li>
<li>  “-q” 选项表示不输出解压缩过程的任何信息，即 “quiet” 模式。</li>
<li>  “file.zip” 是要解压缩的 zip 文件的名称。</li>
</ul>
<p>这个命令将会解压缩当前目录下的”file.zip” 压缩文件，并将其中的文件提取到当前目录下。其中，”.zip” 表示文件经过 zip 命令压缩过。需要注意的是，该命令只能用于解压缩 zip 命令压缩的文件。</p>
<h2 id="Redis-存储系统"><a href="#Redis-存储系统" class="headerlink" title="Redis 存储系统"></a>Redis 存储系统</h2><h3 id="什么是-Redis？"><a href="#什么是-Redis？" class="headerlink" title="什么是 Redis？"></a>什么是 Redis？</h3><p>Remote Dictionary Server (Redis) 是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key- Value 数据库，并提供多种语言的 API。它通常被称为数据结构服务器，因为值（value）可以是 字符串 (String), 哈希 (Map), 列表 (list), 集合 (sets) 和 有序集合 (sorted sets) 等类型。</p>
<h3 id="Redis-的特点什么是？"><a href="#Redis-的特点什么是？" class="headerlink" title="Redis 的特点什么是？"></a>Redis 的特点什么是？</h3><ol>
<li> 支持多种数据结构，如 String (字符串)、 List (列表)、Hash (哈希表)、Set (集合)、Sorted Set (有序集合)、HyperLogLog (基数估算)。</li>
<li> 支持持久化操作，可以进行 aof 及 rdb 数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。</li>
<li> 支持通过 Replication 进行数据复制，通过 master-slave 机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave 机制是 Redis 进行 HA 的重要手段。</li>
<li> 单进程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。</li>
</ol>
<h3 id="Redis-数据类型有哪些？"><a href="#Redis-数据类型有哪些？" class="headerlink" title="Redis 数据类型有哪些？"></a>Redis 数据类型有哪些？</h3><ol>
<li> String (字符串)</li>
<li> Hash (hash 表)</li>
<li> List (链表)</li>
<li> Set (集合)</li>
<li> Sorted Set (有序集合 zset)</li>
</ol>
<h3 id="Redis-的配置以及持久化方案有几种？"><a href="#Redis-的配置以及持久化方案有几种？" class="headerlink" title="Redis 的配置以及持久化方案有几种？"></a>Redis 的配置以及持久化方案有几种？</h3><ol>
<li> RDB 方式</li>
<li> AOF 方式</li>
</ol>
<h3 id="Redis-中的常用命令哪些？"><a href="#Redis-中的常用命令哪些？" class="headerlink" title="Redis 中的常用命令哪些？"></a>Redis 中的常用命令哪些？</h3><ol>
<li> hset 存储一个哈希键值对的集合</li>
<li> hget 获取一个哈希键的值</li>
<li> hdel 删除一个或多个字段</li>
<li> hgetall 获取一个哈希是键值对的集合</li>
<li> lpush key value 向链表左侧添加</li>
<li> rpush key value 向链表右侧添加</li>
<li> lpop key 从左边移出一个元素</li>
<li> rpop key 从右边移出一个元素</li>
<li> keys * 返回所有的 key 可以加 * 通配</li>
<li> exists key 判断 string 类型一个 key 是否存在 如果存在返回 1 否则返回 0</li>
</ol>
<h3 id="Redis-主要消耗什么物理资源？"><a href="#Redis-主要消耗什么物理资源？" class="headerlink" title="Redis 主要消耗什么物理资源？"></a>Redis 主要消耗什么物理资源？</h3><p>内存</p>
<h3 id="Redis-有哪几种数据淘汰策略？"><a href="#Redis-有哪几种数据淘汰策略？" class="headerlink" title="Redis 有哪几种数据淘汰策略？"></a>Redis 有哪几种数据淘汰策略？</h3><ol>
<li> noeviction: 返回错误当内存限制达到，并且客户端尝试执行会让更多内存被使用的命令。</li>
<li> allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</li>
<li> volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键，使得新添加的数据有空间存放。</li>
<li> allkeys-random: 回收随机的键使得新添加的数据有空间存放。</li>
<li> volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</li>
<li> volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键，使得新添加的数据有空间存放。</li>
</ol>
<h3 id="Redis-官方为什么不提供-Windows-版本？"><a href="#Redis-官方为什么不提供-Windows-版本？" class="headerlink" title="Redis 官方为什么不提供 Windows 版本？"></a>Redis 官方为什么不提供 Windows 版本？</h3><p>因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发 windows 版本，反而会带来兼容性等问题。</p>
<h3 id="为什么-Redis-需要把所有数据放到内存中？"><a href="#为什么-Redis-需要把所有数据放到内存中？" class="headerlink" title="为什么 Redis 需要把所有数据放到内存中？"></a>为什么 Redis 需要把所有数据放到内存中？</h3><p>Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 Redis 具有快速和数据持久化的特征，如果不将数据放在内存中，磁盘 I/O 速度为严重影响 Redis 的性能。在内存越来越便宜的今天，Redis 将会越来越受欢迎， 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<h3 id="Redis-有哪些适合的场景？"><a href="#Redis-有哪些适合的场景？" class="headerlink" title="Redis 有哪些适合的场景？"></a>Redis 有哪些适合的场景？</h3><ol>
<li> 会话缓存（Session Cache）：最常用的一种使用 Redis 的情景是会话缓存（Session Cache），用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台 Magento 也提供 Redis 的插件。</li>
<li> 全页缓存（FPC）：除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</li>
<li> 队列：Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop 操作。如果你快速的在 Google 中搜索 “Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。</li>
<li> 排行榜 / 计数器：Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（SortedSet）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。</li>
<li> 发布 / 订阅：最后（但肯定不是最不重要的）是 Redis 的发布 / 订阅功能。发布 / 订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布 / 订阅的脚本触发器，甚至用</li>
</ol>
<h2 id="Spring-Boot-框架"><a href="#Spring-Boot-框架" class="headerlink" title="Spring Boot 框架"></a>Spring Boot 框架</h2><h3 id="什么是-Spring-Boot？"><a href="#什么是-Spring-Boot？" class="headerlink" title="什么是 Spring Boot？"></a>什么是 Spring Boot？</h3><p>多年来，随着新功能的增加，Spring 变得越来越复杂。只需访问 <a target="_blank" rel="noopener" href="https://spring.io/projects">https://spring.io/projects</a> 页面，我们就会看到可以在我们的应用程序中使用的所有 Spring 项目的不同功能。如果必须启动一个新的 Spring 项目，我们必须添加构建路径或添加 Maven 依赖关系，配置应用程序服务器，添加 Spring 配置。因此，开始一个新的 Spring 项目需要很多努力，因为我们现在必须从头开始做所有事情。Spring Boot 是解决这个问题的方法。Spring Boot 已经建立在现有 Spring 框架之上。使用 Spring 启动，我们避免了之前我们必须做的所有样板代码和配置。因此，Spring Boot 可以帮助我们以最少的工作量，更加健壮地使用现有的 Spring 功能。</p>
<h3 id="Spring-Boot-有哪些特点？"><a href="#Spring-Boot-有哪些特点？" class="headerlink" title="Spring Boot 有哪些特点？"></a>Spring Boot 有哪些特点？</h3><ol>
<li> 为 Spring 开发提供一个更快、更广泛的入门体验。</li>
<li> 开箱即用，远离繁琐的配置。</li>
<li> 提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li>
<li> 绝对没有代码生成，也不需要 XML 配置。</li>
</ol>
<h3 id="Spring-Boot-有哪些优点？"><a href="#Spring-Boot-有哪些优点？" class="headerlink" title="Spring Boot 有哪些优点？"></a>Spring Boot 有哪些优点？</h3><ol>
<li> 减少开发、测试时间和努力。</li>
<li> 使用 JavaConfig 有助于避免使用 XML。</li>
<li> 避免大量的 Maven 导入和各种版本冲突。</li>
<li> 通过提供默认值快速开始开发。没有单独的 Web 服务器需要。这意味着你不再需要启动 Tomcat，Glassfish 或其他任何东西。</li>
<li> 需要更少的配置 因为没有 web.xml 文件。只需添加用 <code>@ Configuration</code> 注释的类，然后添加用 <code>@Bean</code> 注释的方法，Spring 将自动加载对象并像以前一样对其进行管理。您甚至可以将 <code>@Autowired</code> 添加到 bean 方法中，以使 Spring 自动装入需要的依赖关系中。基于环境的配置 使用这些属性，您可以将您正在使用的环境传递到应用程序：-Dspring.profiles.active ={enviornment}。在加载主应用程序属性文件后，Spring 将在（application {environment} .properties）中加载后续的应用程序属性文件。</li>
</ol>
<h3 id="Spring-Boot、Spring-MVC-和-Spring-有什么区别？"><a href="#Spring-Boot、Spring-MVC-和-Spring-有什么区别？" class="headerlink" title="Spring Boot、Spring MVC 和 Spring 有什么区别？"></a>Spring Boot、Spring MVC 和 Spring 有什么区别？</h3><ol>
<li> Spring 最重要的特征是依赖注入。所有 SpringModules 不是依赖注入就是 IOC 控制反转。当我们恰当的使用 DI 或者是 IOC 的时候，我们可以开发松耦合应用。松耦合应用的单元测试可以很容易的进行。</li>
<li> Spring MVC 提供了一种分离式的方法来开发 Web 应用。通过运用像 DispatcherServelet ， MoudlAndView 和 ViewResolver 等一些简单的概念，开发 Web 应用将会变得非常简单。</li>
<li> Spring 和 SpringMVC 的问题在于需要配置大量的参数。Spring Boot 通过一个自动配置和启动的项来目解决这个问题。为了更快的构建产品就绪应用程序，Spring Boot 提供了一些非功能性特征。</li>
</ol>
<h3 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h3><p>启动类上面的注解是 @SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 4 个注解：</p>
<ol>
<li> @SpringBootConfiguration： 组 合 了 @Configuration 注 解 ， 实 现 配 置 文 件 的 功 能 。</li>
<li> @EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：</li>
<li> @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</li>
<li> @ComponentScan：Spring 组件扫描。</li>
</ol>
<h3 id="Spring-Boot-需要独立的容器运行吗？"><a href="#Spring-Boot-需要独立的容器运行吗？" class="headerlink" title="Spring Boot 需要独立的容器运行吗？"></a>Spring Boot 需要独立的容器运行吗？</h3><p>可以不需要，内置了 Tomcat/Jetty 等容器。</p>
<h3 id="你如何理解-Spring-Boot-中的-Starters？"><a href="#你如何理解-Spring-Boot-中的-Starters？" class="headerlink" title="你如何理解 Spring Boot 中的 Starters？"></a>你如何理解 Spring Boot 中的 Starters？</h3><p>Starters 可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成 Spring 及其他技术，而不需要到处找示例代码和依赖包。如你想使用 Spring JPA 访问数据库，只要加入 spring-boot-starter-data-jpa 启动器依赖就能使用了。</p>
<h3 id="Spring-Boot-是否可以使用-XML-配置？"><a href="#Spring-Boot-是否可以使用-XML-配置？" class="headerlink" title="Spring Boot 是否可以使用 XML 配置？"></a>Spring Boot 是否可以使用 XML 配置？</h3><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 <code>@ImportResource</code> 注解可以引入一个 XML 配置。</p>
<h3 id="bootstrap-properties-和-application-properties-有何区别？"><a href="#bootstrap-properties-和-application-properties-有何区别？" class="headerlink" title="bootstrap.properties 和 application.properties 有何区别？"></a>bootstrap.properties 和 application.properties 有何区别？</h3><ol>
<li> 单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。bootstrap.properties 在 application.properties 之前加载，配置在应用程序上下文的引导阶段生效。</li>
<li> 一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。bootstrap.properties 被 Spring ApplicationContext 的父类加载，这个类先于加载 application.properties 的 ApplicatonContext 启动。当然，前面叙述中的 properties 也可以修改为 yaml 。</li>
</ol>
<h3 id="自动装配的原理"><a href="#自动装配的原理" class="headerlink" title="自动装配的原理"></a>自动装配的原理</h3><p>@EnableAutoConfiguration 的实现关键在于引入了 AutoConfigurationImportSelector，该类的核心逻辑是 selectImports 方法。在该方法中，首先会从 spring-boot-autoconfigure 包下的 META-INF/spring.factories 文件中加载所有可能用到的自动配置类；然后进行去重操作，并排除 exclude 和 excludeName 属性携带的类；最后进行过滤操作，只将满足条件（@Conditional）的自动配置类返回。这样，通过使用 @EnableAutoConfiguration 注解，就可以实现自动配置的功能。</p>
<h3 id="如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？"><a href="#如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？" class="headerlink" title="如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？"></a>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？</h3><p>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式 tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>prg.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">opential</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="如何在自定义端口上运行-Spring-Boot-应用程序？"><a href="#如何在自定义端口上运行-Spring-Boot-应用程序？" class="headerlink" title="如何在自定义端口上运行 Spring Boot 应用程序？"></a>如何在自定义端口上运行 Spring Boot 应用程序？</h3><p>为了在自定义端口上运行 Spring Boot 应用程序，您可以在 application.properties 中指定端口。</p>
<h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><h3 id="什么是-Spring-Cloud？"><a href="#什么是-Spring-Cloud？" class="headerlink" title="什么是 Spring Cloud？"></a>什么是 Spring Cloud？</h3><ol>
<li> Spring Cloud 是一个微服务框架，相比 Dubbo 等 RPC 框架，Spring Cloud 提供的全套的分布式系统解决方案。</li>
<li> Spring Cloud 对微服务基础框架 Netflix 的多个开源组件进行了封装，同时又实现了和云端平台以及和 Spring Boot 开发框架的集成。</li>
<li> Spring Cloud 为微服务架构开发涉及的配置管理，服务治理，熔断机制，智能路由，微代理，控制总线，一次性 token，全局一致性锁，leader 选举，分布式 session，集群状态管理等操作提供了一种简单的开发方式。</li>
<li> Spring Cloud 为开发者提供了快速构建分布式系统的工具，开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。</li>
</ol>
<h3 id="Spring-Cloud-与-Dubbo-的区别是什么？"><a href="#Spring-Cloud-与-Dubbo-的区别是什么？" class="headerlink" title="Spring Cloud 与 Dubbo 的区别是什么？"></a>Spring Cloud 与 Dubbo 的区别是什么？</h3><table width="1022"><tbody><tr><td colspan="2" width="235">对比项</td><td width="273">Dubbo</td><td width="393">Spring Cloud</td></tr><tr><td colspan="2">出生背景</td><td>阿里系。核心框架是服务化治理</td><td>Spring 社区。核心框架是 Netflix 开源微服务架构群体</td></tr><tr><td rowspan="3">活跃度</td><td>社区活跃度</td><td colspan="2">相差不多但是 Spring Cloud 相对更活跃一些</td></tr><tr><td>百度指数</td><td>2570</td><td>999</td></tr><tr><td>招聘岗位</td><td>636</td><td>160</td></tr><tr><td colspan="2">文档质量</td><td>集中，健全</td><td>较多，内容大部分是英文版</td></tr><tr><td colspan="2">性能</td><td colspan="2">1:3</td></tr><tr><td rowspan="9">功能</td><td>服务注册中心</td><td>ZooKeeper</td><td>Spring Cloud Netflix Eureka</td></tr><tr><td>服务调用方式</td><td>PRC</td><td>REST API</td></tr><tr><td>服务网关</td><td>无</td><td>Spring Cloud Netflix Zuul</td></tr><tr><td>断路由</td><td>集群容错</td><td>Spring Cloud Netflix Hystrix</td></tr><tr><td>分布式配置</td><td>无</td><td>Spring Cloud Config</td></tr><tr><td>服务跟踪</td><td>无</td><td>Spring Cloud Sleuth</td></tr><tr><td>消息总线</td><td>无</td><td>Spring Cloud Bus</td></tr><tr><td>数据流</td><td>无</td><td>Spring Cloud Stream</td></tr><tr><td>批量任务</td><td>无</td><td>Spring Cloud Task</td></tr></tbody></table>

<h3 id="Spring-Cloud-断路器的作用是什么？"><a href="#Spring-Cloud-断路器的作用是什么？" class="headerlink" title="Spring Cloud 断路器的作用是什么？"></a>Spring Cloud 断路器的作用是什么？</h3><p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p>
<h2 id="Spring-Cloud-的核心组件有哪些？"><a href="#Spring-Cloud-的核心组件有哪些？" class="headerlink" title="Spring Cloud 的核心组件有哪些？"></a>Spring Cloud 的核心组件有哪些？</h2><ol>
<li> Eureka：服务注册于发现。</li>
<li> Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。</li>
<li> Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。</li>
<li> Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</li>
<li> Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</li>
</ol>
<h3 id="Spring-Cloud-如何实现服务的注册？"><a href="#Spring-Cloud-如何实现服务的注册？" class="headerlink" title="Spring Cloud 如何实现服务的注册？"></a>Spring Cloud 如何实现服务的注册？</h3><p>在服务发布时，需要指定对应的服务名，并将该服务注册到注册中心（例如 Eureka、Zookeeper 等）。可以使用 @EnableEurekaServer 注解开启注册中心，使用 @EnableDiscoveryClient 注解将服务注册到注册中心，然后使用 Ribbon 或 Feign 等工具进行服务之间的调用和发现。这样可以实现服务之间的相互调用，提高应用程序的可扩展性和弹性。</p>
<h3 id="Eureka-自我保护机制是什么？"><a href="#Eureka-自我保护机制是什么？" class="headerlink" title="Eureka 自我保护机制是什么？"></a>Eureka 自我保护机制是什么？</h3><p>当 Eureka Server 节点在短时间内丢失了过多实例的连接时（比如网络故障或频繁启动关闭客户端）节点会进入自我保护模式， 保护注册信息，不再删除注册数据，故障恢复时，自动退出自我保护模式。</p>
<h3 id="什么是-Ribbon？"><a href="#什么是-Ribbon？" class="headerlink" title="什么是 Ribbon？"></a>什么是 Ribbon？</h3><p>Ribbon 是一个负载均衡客户端，可以很好地控制 HTTP 和 TCP 的一些行为。Feign 默认集成了 Ribbon。</p>
<h3 id="什么是-Spring-Cloud-Bus"><a href="#什么是-Spring-Cloud-Bus" class="headerlink" title="什么是 Spring Cloud Bus?"></a>什么是 Spring Cloud Bus?</h3><p>Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来，它可以用于广播配置文件的更改或者服务直接的通讯，也可用于监控。如果修改了配置文件，发送一次请求，所有的客户端便会重新读取配置文件。</p>
<h3 id="什么是-Eureka-注册中心？"><a href="#什么是-Eureka-注册中心？" class="headerlink" title="什么是 Eureka 注册中心？"></a>什么是 Eureka 注册中心？</h3><p>Eureka 是 Netflix 开发的服务发现组件，本身是一个基于 REST 的服务。Spring Cloud 将它集成在其子项目 spring-cloud-netflix 中， 以实现 Spring Cloud 的服务注册于发现，同时还提供了负载均衡、故障转移等能力。</p>
<h3 id="负载平衡的意义什么？"><a href="#负载平衡的意义什么？" class="headerlink" title="负载平衡的意义什么？"></a>负载平衡的意义什么？</h3><p>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</p>
<h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><h3 id="Dubbo-是什么？"><a href="#Dubbo-是什么？" class="headerlink" title="Dubbo 是什么？"></a>Dubbo 是什么？</h3><p>Dubbo 是阿里巴巴开源的基于 Java 的高性能 RPC 分布式服务框架，现已成为 Apache 基金会孵化项目。</p>
<h3 id="Dubbo-默认使用什么注册中心，还有别的选择吗？"><a href="#Dubbo-默认使用什么注册中心，还有别的选择吗？" class="headerlink" title="Dubbo 默认使用什么注册中心，还有别的选择吗？"></a>Dubbo 默认使用什么注册中心，还有别的选择吗？</h3><p>推荐使用 ZooKeeper 作为注册中心，还有 Redis、Multicast、Simple 注册中心，但不推荐。</p>
<h3 id="在-Provider-上可以配置的-Consumer-端的属性有哪些？"><a href="#在-Provider-上可以配置的-Consumer-端的属性有哪些？" class="headerlink" title="在 Provider 上可以配置的 Consumer 端的属性有哪些？"></a>在 Provider 上可以配置的 Consumer 端的属性有哪些？</h3><ol>
<li> timeout：方法调用超时</li>
<li> retries：失败重试次数，默认重试 2 次</li>
<li> loadbalance：负载均衡算法，默认随机</li>
<li> actives 消费者端，最大并发调用限制</li>
</ol>
<h3 id="Dubbo-推荐使用什么序列化框架，你知道的还有哪些？"><a href="#Dubbo-推荐使用什么序列化框架，你知道的还有哪些？" class="headerlink" title="Dubbo 推荐使用什么序列化框架，你知道的还有哪些？"></a>Dubbo 推荐使用什么序列化框架，你知道的还有哪些？</h3><p>推荐使用 Hessian 序列化，还有 Duddo、FastJson、Java 自带序列化。</p>
<h3 id="你还了解别的分布式框架吗？"><a href="#你还了解别的分布式框架吗？" class="headerlink" title="你还了解别的分布式框架吗？"></a>你还了解别的分布式框架吗？</h3><p>别的还有 Spring cloud、Facebook 的 Thrift、Twitter 的 Finagle 等。</p>
<h3 id="Dubbo-内置了哪几种服务容器？"><a href="#Dubbo-内置了哪几种服务容器？" class="headerlink" title="Dubbo 内置了哪几种服务容器？"></a>Dubbo 内置了哪几种服务容器？</h3><p>Spring Container，Jetty Container，Log4j Container</p>
<h3 id="Dubbo-核心的配置有哪些？"><a href="#Dubbo-核心的配置有哪些？" class="headerlink" title="Dubbo 核心的配置有哪些？"></a>Dubbo 核心的配置有哪些？</h3><table width="550"><tbody><tr><td width="155">配置</td><td width="179">配置说明</td></tr><tr><td>dubbo:service</td><td>服务配置</td></tr><tr><td>dubbo:reference</td><td>引用配置</td></tr><tr><td>dubbo:protocol</td><td>协议配置</td></tr><tr><td>dubbo:application</td><td>应用配置</td></tr><tr><td>dubbo:module</td><td>模块配置</td></tr><tr><td>dubbo:registry</td><td>注册中心配置</td></tr><tr><td>dubbo:monitor</td><td>监控中心配置</td></tr><tr><td>dubbo:provider</td><td>提供方配置</td></tr><tr><td>dubbo:consumer</td><td>消费方配置</td></tr><tr><td>dubbo:method</td><td>方法配置</td></tr><tr><td>dubbo:argument</td><td>参数配置</td></tr></tbody></table>

<h3 id="Dubbo-有哪几种集群容错方案，默认是哪种？"><a href="#Dubbo-有哪几种集群容错方案，默认是哪种？" class="headerlink" title="Dubbo 有哪几种集群容错方案，默认是哪种？"></a>Dubbo 有哪几种集群容错方案，默认是哪种？</h3><table width="550"><tbody><tr><td width="161">集群容错方案</td><td width="337">说明</td></tr><tr><td>Failover Cluster</td><td>失败自动切换，自动重试其他服务器（默认）</td></tr><tr><td>Failfast Cluster</td><td>快速失败，立即报错，只发起一次调用</td></tr><tr><td>Failsafe Cluster</td><td>失败安全，出现异常时，直接忽略</td></tr><tr><td>Failback Cluster</td><td>失败自动恢复，记录失败请求，定时重发</td></tr><tr><td>Forking Cluster</td><td>并行调用多个服务器，只要一个成功即返回</td></tr><tr><td>Broadcast Cluster</td><td>广播逐个调用所有提供者，任意一个报错则报错</td></tr></tbody></table>

<h3 id="Dubbo-有哪几种负载均衡策略，默认是哪种？"><a href="#Dubbo-有哪几种负载均衡策略，默认是哪种？" class="headerlink" title="Dubbo 有哪几种负载均衡策略，默认是哪种？"></a>Dubbo 有哪几种负载均衡策略，默认是哪种？</h3><table width="627"><tbody><tr><td width="199">负载均衡策略</td><td width="307">说明</td></tr><tr><td>Random LoadBalance</td><td>随机，按权重设置随机概率（默认）</td></tr><tr><td>RoundRobin LoadBalance</td><td>轮询，按公约后的权重设置轮询比率</td></tr><tr><td>LeastActive LoadBalance</td><td>最少活跃调用数，相同活跃数的随机</td></tr><tr><td>ConsistentHash LoadBalance</td><td>一致性 Hash，相同参数的请求总是发到同一提供者</td></tr></tbody></table>

<h3 id="Dubbo-的优势"><a href="#Dubbo-的优势" class="headerlink" title="Dubbo 的优势"></a>Dubbo 的优势</h3><ol>
<li> 单一应用架构，当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增 删改查工作量的 数据访问框架（ORM）是关键。</li>
<li> 垂直应用架构，当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效 率。此时，用于加速前端页面开发的 Web 框架（MVC）是关键。</li>
<li> 分布式服务架构，当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的 服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的 分布式服务框架（RPC）是关键。</li>
<li> 流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的 资源调度和治理中心（SOA）是关键。</li>
</ol>
<h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><h3 id="ZooKeeper-是什么？"><a href="#ZooKeeper-是什么？" class="headerlink" title="ZooKeeper 是什么？"></a>ZooKeeper 是什么？</h3><p>ZooKeeper 是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。分布式应用程序可以基于 Zookeeper 实现诸如数据发布 / 订阅、负载均衡、命名服务、分布式协调 / 通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p>
<h3 id="ZooKeeper-提供了什么？"><a href="#ZooKeeper-提供了什么？" class="headerlink" title="ZooKeeper 提供了什么？"></a>ZooKeeper 提供了什么？</h3><ol>
<li> 文件系统</li>
<li> 通知机制</li>
</ol>
<h3 id="Zookeeper-文件系统"><a href="#Zookeeper-文件系统" class="headerlink" title="Zookeeper 文件系统"></a>Zookeeper 文件系统</h3><p>Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于 存放大量的数据，每个节点的存放数据上限为 1M。</p>
<h3 id="四种类型的数据节点-Znode"><a href="#四种类型的数据节点-Znode" class="headerlink" title="四种类型的数据节点 Znode"></a>四种类型的数据节点 Znode</h3><ol>
<li> PERSISTENT - 持久化目录节点客户端与 zookeeper 断开连接后，该节点依旧存在。</li>
<li> PERSISTENT_SEQUENTIAL - 持久化顺序编号目录节点客户端与 zookeeper 断开连接后，该节点依旧存在，只是 Zookeeper 给该节点名称进行序编号。</li>
<li> EPHEMERAL - 临时目录节点客户端与 zookeeper 断开连接后，该节点被删。</li>
<li> EPHEMERAL_SEQUENTIAL - 临时顺序编号目录节点客户端与 zookeeper 断开连接后，该节点被删除，只是 Zookeeper 给该节点名称进行顺序号。</li>
</ol>
<h3 id="Zookeeper-通知机制"><a href="#Zookeeper-通知机制" class="headerlink" title="Zookeeper 通知机制"></a>Zookeeper 通知机制</h3><p>Client 端会对某个 ZNode 建立一个 Watcher 事件，当该 ZNode 发生变化时，这些 Client 会收到 ZooKeeper 的通知，然后 Client 可以根据 ZNode 变化来做出业务上的改变等。</p>
<h3 id="ZooKeeper-负载均衡和-Nginx-负载均衡区别"><a href="#ZooKeeper-负载均衡和-Nginx-负载均衡区别" class="headerlink" title="ZooKeeper 负载均衡和 Nginx 负载均衡区别"></a>ZooKeeper 负载均衡和 Nginx 负载均衡区别</h3><p>ZooKeeper 的负载均衡是可以调控，Nginx 只是能调权重，其他需要可控的都需要自己写插件；但是 Nginx 的吞吐量比 ZooKeeper 大很多，应该说按业务选择用哪种方式。</p>
<h3 id="ZooKeeper-工作原理"><a href="#ZooKeeper-工作原理" class="headerlink" title="ZooKeeper 工作原理"></a>ZooKeeper 工作原理</h3><p>ZooKeeper 的核心是原子广播，这个机制保证了各个 Server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。</p>
<h3 id="ZooKeeper-是如何保证事务的顺序一致性的？"><a href="#ZooKeeper-是如何保证事务的顺序一致性的？" class="headerlink" title="ZooKeeper 是如何保证事务的顺序一致性的？"></a>ZooKeeper 是如何保证事务的顺序一致性的？</h3><p>ZooKeeper 采用了递增的事务 ID 来标识，所有的 Proposal（提议）都在被提出的时候加上了 ZXID，ZXID 实际上是一个 64 位的数字，高 32 位是 Epoch（时期；纪元；世；新时代）用来标识 Leader 是否发生改变，如果有新的 Leader 产生出来，Epoch 会自增，低 32 位用来递 增计数。当新产生 Proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 Server 发出事务执行请求，如果超过半数的机器都 能执行并且能够成功，那么就会开始执行。</p>
<h2 id="JVM-面试专题"><a href="#JVM-面试专题" class="headerlink" title="JVM 面试专题"></a>JVM 面试专题</h2><h3 id="内存模型以及分区，需要详细到每个区放什么？"><a href="#内存模型以及分区，需要详细到每个区放什么？" class="headerlink" title="内存模型以及分区，需要详细到每个区放什么？"></a>内存模型以及分区，需要详细到每个区放什么？</h3><p>JVM 分为堆区和栈区，还有方法区，初始化的对象放在堆里面，引用放在栈里面，class 类信息常量池（static 常量和 static 变量）等放在方法区 a、方法区：主要是存储类信息，常量池（static 常量和 static 变量），编译后的代码（字节码）等数</p>
<ol>
<li> 堆：初始化的对象，成员变量 （那种非 static 的变量），所有的对象实例和数组都要在堆上分配。</li>
<li> 栈：栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操作数栈，方法出口等信息，局部变量表存放的是 8 大基础类型加上一个应用类 型，所以还是一个指向地址的指针。</li>
<li> 本地方法栈：主要为 Native 方服务。</li>
<li> 程序计数器：记录当前线程执行的行号。</li>
</ol>
<h3 id="堆里面的分区：Eden，survival-（from-to），老年代，各自的特点。"><a href="#堆里面的分区：Eden，survival-（from-to），老年代，各自的特点。" class="headerlink" title="堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。"></a>堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。</h3><ol>
<li> 堆里面分为新生代和老生代（java8 取消了永久代，采用了 Metaspace），新生代包含 Eden+Survivor 区，survivor 区里面分为 from 和 to 区， 内存回收时，如果用的是复制算法，从 from 复制到 to，当经过一次或者多次 GC 之后，存活下来的对象会被移动到老年区，当 JVM 内存不够用的时候，会触发 Full GC，清理 JVM 老年区当新生区满了之后会触发 YGC, 先把存活的对象放到其中一个 Survice 区，然后进行垃圾清理。</li>
<li> 因为如果仅仅清理需要删除的对象，这样会导致内存碎片，因此一般会把 Eden 进行完全的清理，然后整理内存。那么下次 GC 的时候，就会使用下一个 Survive，这样循环使用。如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。因为 JVM 认为，一般大对象的存活时间一般比较久远。</li>
</ol>
<h3 id="GC-的两种判定方法："><a href="#GC-的两种判定方法：" class="headerlink" title="GC 的两种判定方法："></a>GC 的两种判定方法：</h3><ol>
<li> 引用计数法：指的是如果某个地方引用了这个对象就 + 1，如果失效了就 - 1，当为 0 就会回收但是 JVM 没有用这种方式，因为无法判定相互循环引用（A 引用 B,B 引用 A）的情况。</li>
<li> 引用链法： 通过一种 GC ROOT 的对象（方法区中静态变量引用的对象等 - static 变量）来判断，如果有一条链能够到达 GCROOT 就说明，不能到达 GC ROOT 就说明可以回收。</li>
</ol>
<h3 id="GC-的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？"><a href="#GC-的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？" class="headerlink" title="GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？"></a>GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？</h3><p>先标记，标记完毕之后再清除，效率不高，会产生碎片复制算法：分为 8：1 的 Eden 区和 survivor 区，就是上面谈到的 YGC 标记整理：标记完毕之后，让所有存活的对象向一端移动。</p>
<h3 id="GC-收集器有哪些？CMS-收集器与-G1-收集器的特点。"><a href="#GC-收集器有哪些？CMS-收集器与-G1-收集器的特点。" class="headerlink" title="GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。"></a>GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。</h3><ol>
<li> 并行收集器：串行收集器使用单个线程进行垃圾收集，会在 GC 时停止服务。而并行收集器使用多个线程同时进行垃圾收集，可以更快地完成垃圾回收。</li>
<li> 并发收集器：在 GC 时服务不会停止，使用多线程来执行垃圾回收，因此不会出现长时间停顿的情况。CMS 收集器就是一种并发收集器，它是基于 “标记 — 清除” 算法实现的，会经过多次标记才会进行垃圾回收。</li>
<li> CMS 收集器的特点：是一种并发收集器，能够在 GC 时服务不停顿，但因为采用标记清除算法，容易出现碎片化问题，可能导致频繁进行 Full GC，从而影响系统的性能。</li>
<li> G1 收集器的特点：从整体上看是基于 “标记 — 整理” 算法实现的收集器，会对堆内存进行划分，然后使用多个线程并发执行垃圾回收。从局部（两个 Region 之间）上看是基于 “复制” 算法实现的，可以避免碎片化问题，因此能够更好地保证系统的性能。同时，G1 收集器还能够根据垃圾分布情况来优化垃圾回收过程，进一步提高系统的性能。</li>
</ol>
<h3 id="Minor-GC-与-Full-GC-分别在什么时候发生？"><a href="#Minor-GC-与-Full-GC-分别在什么时候发生？" class="headerlink" title="Minor GC 与 Full GC 分别在什么时候发生？"></a>Minor GC 与 Full GC 分别在什么时候发生？</h3><p>新生代内存不够用时候发生 MGC 也叫 YGC，JVM 内存不够的时候发生 FGC。</p>
<h3 id="简述-Java-垃圾回收机制？"><a href="#简述-Java-垃圾回收机制？" class="headerlink" title="简述 Java 垃圾回收机制？"></a>简述 Java 垃圾回收机制？</h3><p>在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合 中，进行回收。</p>
<h3 id="Java-中垃圾收集的方法有哪些？"><a href="#Java-中垃圾收集的方法有哪些？" class="headerlink" title="Java 中垃圾收集的方法有哪些？"></a>Java 中垃圾收集的方法有哪些？</h3><ol>
<li> 标记 - 清除：这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：1.1. 效率不高，标记和清除的效率都很低；1.2. 会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作。</li>
<li> 复制算法：为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。于是将该算法进行了改进，内存区域不再是按照 1：1 去划分，而是将内存划分为 8:1:1 三部分，较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。每次都会优先使用 Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担保机制复制到老年代中。(Java 堆又分为新生代和老年代)。</li>
<li> 标记 - 整理：该算法主要是为了解决标记 - 清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。</li>
<li> 分代收集：现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记 - 整理 或者 标记 - 清除。</li>
</ol>
<h3 id="简述-Java-类加载机制？"><a href="#简述-Java-类加载机制？" class="headerlink" title="简述 Java 类加载机制？"></a>简述 Java 类加载机制？</h3><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。</p>
<h3 id="什么是类加载器，类加载器有哪些？"><a href="#什么是类加载器，类加载器有哪些？" class="headerlink" title="什么是类加载器，类加载器有哪些？"></a>什么是类加载器，类加载器有哪些？</h3><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。主要有一下四种类加载器:</p>
<ol>
<li> 启动类加载器 (Bootstrap ClassLoader) 用来加载 java 核心类库，无法被 java 程序直接引用。</li>
<li> 扩展类加载器 (extensions class loader): 它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li> 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader () 来获取它。</li>
<li> 用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。</li>
</ol>
<h3 id="说一下-JVM-调优的工具？"><a href="#说一下-JVM-调优的工具？" class="headerlink" title="说一下 JVM 调优的工具？"></a>说一下 JVM 调优的工具？</h3><p>DK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。jconsole：用于对 JVM 中的内存、线程和类等进行监控；jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p>
<h3 id="常用的-JVM-调优的参数都有哪些？"><a href="#常用的-JVM-调优的参数都有哪些？" class="headerlink" title="常用的 JVM 调优的参数都有哪些？"></a>常用的 JVM 调优的参数都有哪些？</h3><ol>
<li> <code>-Xms2g</code>：初始化推大小为 2g；</li>
<li> <code>-Xmx2g</code>：堆最大内存为 2g；</li>
<li> <code>-XX:NewRatio=4</code>：设置年轻的和老年代的内存比例为 1:4；</li>
<li> <code>-XX:SurvivorRatio=8</code>：设置新生代 Eden 和 Survivor 比例为 8:2；</li>
<li> <code>–XX:+UseParNewGC</code>：指定使用 ParNew + Serial Old 垃圾回收器组合；</li>
<li> <code>-XX:+UseParallelOldGC</code>：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li>
<li> <code>-XX:+UseConcMarkSweepGC</code>：指定使用 CMS + Serial Old 垃圾回收器组合；</li>
<li> <code>-XX:+PrintGC</code>：开启打印 gc 信息；</li>
<li> <code>-XX:+PrintGCDetails</code>：打印 gc 详细</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.skypixel.eu.org">SnowIce</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.skypixel.eu.org/2023/04/06/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">https://blog.skypixel.eu.org/2023/04/06/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.skypixel.eu.org" target="_blank">SnowIce's Hexo Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://snowice.fun/wp-content/uploads/2023/03/R-C-1-1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/03/24/%E6%B5%8B%E8%AF%95/" title="测试"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.snowice.fun/bg-image/html-bk-image/wallhaven-1pq9kv.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">测试</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.snowice.fun/bg-image/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">SnowIce</div><div class="author-info__description">Hexo测试</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Ybb778"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Ybb778" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:yxb666@vip.qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Weclome to SnowIce's Test Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-JRE-JVM-%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">JDK,JRE,JVM 三者关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">面向过程和面向对象的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">Java 有哪些基本数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88-Java-%E6%B3%A8%E9%87%8A%EF%BC%9F"><span class="toc-text">什么 Java 注释？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">数组和集合有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">final 有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final-fially-finalize-%E5%8C%BA%E5%88%AB"><span class="toc-text">final fially finalize 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">面向对象三大特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">&#x3D;&#x3D; 和 equals 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F"><span class="toc-text">String 类的常用方法都有那些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E5%92%8C-StringBuffer%E3%80%81StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FString-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="toc-text">String 和 StringBuffer、StringBuilder 的区别是什么？String 为什么是不可变的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-text">自动装箱与拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int-%E5%92%8C-Integer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">int 和 Integer 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%BA%E6%AF%8F%E4%B8%AA%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">Java 为每个原始类型提供了哪些包装类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E3%80%81LinkedList%E3%80%81Vector-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">ArrayList、LinkedList、Vector 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">HashMap 和 Hashtable 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized-%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%8C%E5%85%B6%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Synchronized 用过吗，其原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Synchronized-%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F"><span class="toc-text">为什么说 Synchronized 是非公平锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Synchronized-%E6%98%AF%E4%B8%80%E4%B8%AA%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9F%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF-CAS%EF%BC%8C%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%80%E5%AE%9A%E5%B0%B1%E6%98%AF%E5%A5%BD%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">乐观锁一定就是好的吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC-%E6%8A%80%E6%9C%AF"><span class="toc-text">JDBC 技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-JDBC%EF%BC%8C%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E7%94%A8%E5%88%B0%E5%AE%83%EF%BC%9F"><span class="toc-text">什么是 JDBC，在什么时候会用到它？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDBC-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">JDBC 访问数据库的基本步骤是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execute-executeQuery-executeUpdate-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">execute, executeQuery, executeUpdate 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDBC-%E7%9A%84-PreparedStatement-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">JDBC 的 PreparedStatement 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E4%BA%8E-Statement%EF%BC%8CPreparedStatement-%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">相对于 Statement，PreparedStatement 的优点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDBC-%E7%9A%84-ResultSet-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">JDBC 的 ResultSet 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-Date-%E5%92%8C-java-sql-Date-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">java.util.Date 和 java.sql.Date 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%9C%A8-JDBC-%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%A4%84%E7%90%86%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-text">说说事务的概念，在 JDBC 编程中处理事务的步骤？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%82%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%9F"><span class="toc-text">数据库连接池的原理。为什么要使用连接池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-JDBC-%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9F"><span class="toc-text">什么是 JDBC 的最佳实践？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF"><span class="toc-text">MySQL 数据库技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E5%88%86%E9%A1%B5%E6%97%B6%E7%94%A8%E7%9A%84%E8%AF%AD%E5%8F%A5"><span class="toc-text">数据库 MySQL 分页时用的语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%BD%A0%E4%BB%A5%E5%BE%80%E7%9A%84%E7%BB%8F%E9%AA%8C%E7%AE%80%E5%8D%95%E5%8F%99%E8%BF%B0%E4%B8%80%E4%B8%8B-MySQL-%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">根据你以往的经验简单叙述一下 MySQL 的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%B8%A4%E5%BC%A0%E8%A1%A8%EF%BC%9B%E8%AF%B7%E7%94%A8-SQL-%E6%9F%A5%E8%AF%A2%EF%BC%8C%E6%89%80%E6%9C%89%E7%9A%84%E5%AE%A2%E6%88%B7%E8%AE%A2%E5%8D%95%E6%97%A5%E6%9C%9F%E6%9C%80%E6%96%B0%E7%9A%84%E5%89%8D%E4%BA%94%E6%9D%A1%E8%AE%A2%E5%8D%95%E8%AE%B0%E5%BD%95%E3%80%82"><span class="toc-text">有两张表；请用 SQL 查询，所有的客户订单日期最新的前五条订单记录。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%AD%EF%BC%8C%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">数据库设计中，一对多如何处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%AD%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E4%B8%80%E8%88%AC%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">数据库设计中，多对多一般如何处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%EF%BC%8C%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">MySQL 数据库中，常用的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Student-%E5%AD%A6%E7%94%9F%E8%A1%A8%EF%BC%88%E5%AD%A6%E5%8F%B7%EF%BC%8C%E5%A7%93%E5%90%8D%E3%80%81%E6%80%A7%E5%88%AB%E3%80%81%E5%B9%B4%E9%BE%84%E3%80%81%E7%BB%84%E7%BB%87%E9%83%A8%E9%97%A8%EF%BC%89%EF%BC%8CCourse-%E8%AF%BE%E7%A8%8B%E8%A1%A8%EF%BC%88%E7%BC%96%E5%8F%B7%EF%BC%8C%E8%AF%BE%E7%A8%8B%E5%90%8D%E7%A7%B0%EF%BC%89%EF%BC%8CSc-%E9%80%89%E8%AF%BE%E8%A1%A8%EF%BC%88%E5%AD%A6%E5%8F%B7%EF%BC%8C%E8%AF%BE%E7%A8%8B%E7%BC%96%E5%8F%B7%EF%BC%8C%E6%88%90%E7%BB%A9%EF%BC%89"><span class="toc-text">Student 学生表（学号，姓名、性别、年龄、组织部门），Course 课程表（编号，课程名称），Sc 选课表（学号，课程编号，成绩）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E"><span class="toc-text">表结构说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2-%E2%80%9C001%E2%80%9D-%E8%AF%BE%E7%A8%8B%E6%AF%94-%E2%80%9C002%E2%80%9D-%E8%AF%BE%E7%A8%8B%E6%88%90%E7%BB%A9%E9%AB%98%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%A6%E7%94%9F%E7%9A%84%E5%AD%A6%E5%8F%B7%EF%BC%9B"><span class="toc-text">查询 “001” 课程比 “002” 课程成绩高的所有学生的学号；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%B9%B3%E5%9D%87%E6%88%90%E7%BB%A9%E5%A4%A7%E4%BA%8E-60-%E5%88%86%E7%9A%84%E5%90%8C%E5%AD%A6%E7%9A%84%E5%AD%A6%E5%8F%B7%E5%92%8C%E5%B9%B3%E5%9D%87%E6%88%90%E7%BB%A9%EF%BC%9B"><span class="toc-text">查询平均成绩大于 60 分的同学的学号和平均成绩；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E5%90%8C%E5%AD%A6%E7%9A%84%E5%AD%A6%E5%8F%B7%E3%80%81%E5%A7%93%E5%90%8D%E3%80%81%E9%80%89%E8%AF%BE%E6%95%B0%E3%80%81%E6%80%BB%E6%88%90%E7%BB%A9%EF%BC%9B"><span class="toc-text">查询所有同学的学号、姓名、选课数、总成绩；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%A7%93-%E2%80%9C%E6%9D%8E%E2%80%9D-%E7%9A%84%E8%80%81%E5%B8%88%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%9B"><span class="toc-text">查询姓 “李” 的老师的个数；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E8%AF%BE%E7%A8%8B%E6%88%90%E7%BB%A9%E5%B0%8F%E4%BA%8E-60-%E5%88%86%E7%9A%84%E5%90%8C%E5%AD%A6%E7%9A%84%E5%AD%A6%E5%8F%B7%E3%80%81%E5%A7%93%E5%90%8D%EF%BC%9B"><span class="toc-text">查询所有课程成绩小于 60 分的同学的学号、姓名；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%87%B3%E5%B0%91%E6%9C%89%E4%B8%80%E9%97%A8%E8%AF%BE%E4%B8%8E%E5%AD%A6%E5%8F%B7%E4%B8%BA-%E2%80%9C1001%E2%80%9D-%E7%9A%84%E5%90%8C%E5%AD%A6%E6%89%80%E5%AD%A6%E7%9B%B8%E5%90%8C%E7%9A%84%E5%90%8C%E5%AD%A6%E7%9A%84%E5%AD%A6%E5%8F%B7%E5%92%8C%E5%A7%93%E5%90%8D%EF%BC%9B"><span class="toc-text">查询至少有一门课与学号为 “1001” 的同学所学相同的同学的学号和姓名；</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E8%AF%AD%E8%A8%80%E5%92%8C-jQuery-%E6%8A%80%E6%9C%AF"><span class="toc-text">JavaScript 语言和 jQuery 技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JS-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%B0%86%E9%A1%B5%E9%9D%A2%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F"><span class="toc-text">JS 中如何将页面重定向到另一个页面？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined%EF%BC%8Cnull-%E5%92%8C-undeclared-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">undefined，null 和 undeclared 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-JavaScript-%E4%B8%AD%E6%AF%8F-x-%E7%A7%92%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">如何在 JavaScript 中每 x 秒调用一个函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS-%E4%B8%AD-%E5%92%8C-%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">JS 中 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E5%86%85%E7%BD%AE%E5%8F%AF%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">JavaScript 内置可用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jQuery-%E5%BA%93%E4%B8%AD%E7%9A%84-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">jQuery 库中的 $() 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jQuery-%E6%9C%89%E5%87%A0%E7%A7%8D%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%9F"><span class="toc-text">jQuery 有几种选择器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jQuery-%E4%B8%AD-get-%E6%8F%90%E4%BA%A4%E5%92%8C-post-%E6%8F%90%E4%BA%A4%E6%9C%89%E5%8C%BA%E5%88%AB%E5%90%97%EF%BC%9F"><span class="toc-text">jQuery 中 $.get () 提交和 $.post () 提交有区别吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window-onload-%E5%87%BD%E6%95%B0%E5%92%8C-jQuery-%E4%B8%AD%E7%9A%84-document-ready-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">window.onload () 函数和 jQuery 中的 document.ready () 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-CDN%EF%BC%9F%E5%93%AA%E4%BA%9B%E6%98%AF%E6%B5%81%E8%A1%8C%E7%9A%84-jQuery-CDN%EF%BC%9F%E4%BD%BF%E7%94%A8-CDN-%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-text">什么是 CDN？哪些是流行的 jQuery CDN？使用 CDN 有什么好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8E-CDN-%E5%8A%A0%E8%BD%BD-jQuery%EF%BC%9F"><span class="toc-text">如何从 CDN 加载 jQuery？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSP-%E6%8A%80%E6%9C%AF"><span class="toc-text">JSP 技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4-Servlet-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-text">说一说 Servlet 的生命周期？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSP-%E5%92%8C-Servlet-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E5%85%B1%E5%90%8C%E7%82%B9%E3%80%81%E5%90%84%E8%87%AA%E5%BA%94%E7%94%A8%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%9F"><span class="toc-text">JSP 和 Servlet 的区别、共同点、各自应用的范围？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet-API-%E4%B8%AD-forward-%E4%B8%8E-redirect-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Servlet API 中 forward () 与 redirect () 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#request-getAttribute-%E5%92%8C-request-getParameter-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">request.getAttribute () 和 request.getParameter () 有何区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC-%E7%9A%84%E5%90%84%E4%B8%AA%E9%83%A8%E5%88%86%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%E6%8A%80%E6%9C%AF%E6%9D%A5%E5%AE%9E%E7%8E%B0%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">MVC 的各个部分都有那些技术来实现？如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSP-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9F%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">JSP 有哪些内置对象？作用分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JSP-%E7%9A%84-4-%E7%A7%8D%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="toc-text">说一下 JSP 的 4 种作用域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session-%E5%92%8C-Cookie-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Session 和 Cookie 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-Session-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">说一下 Session 的工作原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSP-%E4%B8%89%E5%A4%A7%E6%8C%87%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">JSP 三大指令是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-%E7%9A%84%E5%93%8D%E5%BA%94%E7%A0%81-200%EF%BC%8C404%EF%BC%8C302%EF%BC%8C500-%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%90%AB%E4%B9%89%E5%88%86%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-text">http 的响应码 200，404，302，500 表示的含义分别是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E7%9A%84%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">如何解决表单提交的中文乱码问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B-JSTL-%E6%A0%87%E7%AD%BE%EF%BC%9F"><span class="toc-text">你的项目中使用过哪些 JSTL 标签？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%EF%BC%9F"><span class="toc-text">怎么防止重复提交？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Request-%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Request 对象的主要方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSP-%E4%B8%AD%E5%8A%A8%E6%80%81-include-%E5%92%8C%E9%9D%99%E6%80%81-include-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">JSP 中动态 include 和静态 include 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E8%B0%83%E7%94%A8-doGet-%E5%92%8C-doPost"><span class="toc-text">什么情况下调用 doGet () 和 doPost ()?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-%E5%92%8C-post-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">get 和 post 的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E6%A1%86%E6%9E%B6"><span class="toc-text">Spring 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="toc-text">什么是 Spring 框架？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">Spring 的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-IOC%EF%BC%9F"><span class="toc-text">什么是 IOC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-DI"><span class="toc-text">什么是 DI?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">依赖注入的三种实现方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-Spring-%E6%94%AF%E6%8C%81%E7%9A%84%E5%87%A0%E7%A7%8D-bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="toc-text">解释 Spring 支持的几种 bean 的作用域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E6%94%AF%E6%8C%81%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">Spring 支持的事务管理类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E6%9B%B4%E5%80%BE%E5%90%91%E7%94%A8%E9%82%A3%E7%A7%8D%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">你更倾向用那种事务管理类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-AOP"><span class="toc-text">解释 AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%9A%E7%9F%A5%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%94%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%80%9A%E7%9F%A5%EF%BC%9F"><span class="toc-text">什么是通知？有哪五种类型的通知？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC-%E6%A1%86%E6%9E%B6"><span class="toc-text">Spring MVC 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-MVC%EF%BC%9F"><span class="toc-text">什么是 Spring MVC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-MVC-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">Spring MVC 工作原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-MVC-%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">Spring MVC 流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%A0%E4%B9%9F%E7%94%A8%E8%BF%87-Struts2-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8B-Spring-MVC-%E5%92%8C-Struts2-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">如果你也用过 Struts2. 简单介绍下 Spring MVC 和 Struts2 的区别有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RequestMapping-%E6%B3%A8%E8%A7%A3%E7%94%A8%E5%9C%A8%E7%B1%BB%E4%B8%8A%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">@RequestMapping 注解用在类上面有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-MVC-%E7%9A%84%E6%8E%A7%E5%88%B6%E5%99%A8%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">Spring MVC 的控制器是不是单例模式，如果是，有什么问题，怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%A0%B7%E5%9C%A8%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E5%BE%97%E5%88%B0-Request-%E6%88%96%E8%80%85-Session%EF%BC%9F"><span class="toc-text">怎么样在方法里面得到 Request, 或者 Session？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%89%8D%E5%8F%B0%E6%9C%89%E5%BE%88%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BC%A0%E5%85%A5%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%BF%99%E4%BA%9B%E5%8F%82%E6%95%B0%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%EF%BC%8C%E9%82%A3%E4%B9%88%E6%80%8E%E4%B9%88%E6%A0%B7%E5%BF%AB%E9%80%9F%E5%BE%97%E5%88%B0%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">如果前台有很多个参数传入，并且这些参数都是一个对象的，那么怎么样快速得到这个对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-MVC-%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Spring MVC 中函数的返回值是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-MVC-%E6%80%8E%E4%B9%88%E6%A0%B7%E8%AE%BE%E5%AE%9A%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91%E7%9A%84%EF%BC%9F"><span class="toc-text">Spring MVC 怎么样设定重定向和转发的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-MVC-%E6%80%8E%E4%B9%88%E5%92%8C-AJAX-%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">Spring MVC 怎么和 AJAX 相互调用的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-POST-%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%EF%BC%8CGET-%E7%9A%84%E5%8F%88%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%91%A2%EF%BC%9F"><span class="toc-text">如何解决 POST 请求中文乱码问题，GET 的又如何处理呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis-%E6%A1%86%E6%9E%B6"><span class="toc-text">MyBatis 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-MyBatis%EF%BC%9F"><span class="toc-text">什么是 MyBatis？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E5%8A%A8%E6%80%81-SQL-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%A8%E6%80%81-SQL%EF%BC%9F%E8%83%BD%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%8A%A8%E6%80%81-SQL-%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E4%B8%8D%EF%BC%9F"><span class="toc-text">MyBatis 动态 SQL 是做什么的？都有哪些动态 SQL？能简述一下动态 SQL 的执行原理不？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">#{} 和 ${} 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-MyBatis-%E6%98%AF%E5%8D%8A%E8%87%AA%E5%8A%A8-ORM-%E6%98%A0%E5%B0%84%E5%B7%A5%E5%85%B7%EF%BC%9F%E5%AE%83%E4%B8%8E%E5%85%A8%E8%87%AA%E5%8A%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E4%B8%8E-Hibernate-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C"><span class="toc-text">MyBatis 与 Hibernate 有哪些不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">MyBatis 的好处是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-MyBatis-%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%BB%91%E5%AE%9A%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-text">什么是 MyBatis 的接口绑定，有什么好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%91%E5%AE%9A%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">接口绑定有几种实现方式，分别是怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D%E5%92%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%B0%86%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%BB%93%E6%9E%9C%E5%B0%81%E8%A3%85%E5%88%B0%E6%8C%87%E5%AE%9A-POJO%EF%BC%9F"><span class="toc-text">当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定 POJO？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mapper-DAO-%E5%B1%82%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83"><span class="toc-text">Mapper DAO 层开发规范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shiro-%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6"><span class="toc-text">Shiro 安全框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Shiro-%E5%8F%AF%E4%BB%A5%E5%AE%8C%E6%88%90%E5%93%AA%E4%BA%9B%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-text">Shiro 可以完成哪些工作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Apache-Shiro-%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-text">Apache Shiro 的三大核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shiro-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-text">Shiro 有哪些组件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83-Spring-Security-%E5%92%8C-Shiro"><span class="toc-text">比较 Spring Security 和 Shiro</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shiro-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">Shiro 的优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Maven"><span class="toc-text">Maven</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Maven%EF%BC%9F"><span class="toc-text">什么是 Maven？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maven-%E4%BB%93%E5%BA%93%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Maven 仓库是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maven-%E7%9A%84%E5%B7%A5%E7%A8%8B%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Maven 的工程类型有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maven-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Maven 常用命令有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E7%B3%BB%E7%BB%9F"><span class="toc-text">Linux 系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%94%A8%E4%BB%80%E4%B9%88%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%A4%BA%EF%BC%9F%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E3%80%81%E4%B8%8A%E5%B1%82%E7%9B%AE%E5%BD%95%E7%94%A8%E4%BB%80%E4%B9%88%E8%A1%A8%E7%A4%BA%EF%BC%9F%E4%B8%BB%E7%9B%AE%E5%BD%95%E7%94%A8%E4%BB%80%E4%B9%88%E8%A1%A8%E7%A4%BA%EF%BC%9F%E5%88%87%E6%8D%A2%E7%9B%AE%E5%BD%95%E7%94%A8%E4%BB%80%E4%B9%88%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-text">绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示？切换目录用什么命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B%EF%BC%9F%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E9%80%80%E5%87%BA%EF%BC%9F%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E8%B7%AF%E5%BE%84%EF%BC%9F"><span class="toc-text">怎么查看当前进程？怎么执行退出？怎么查看当前路径？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%B8%85%E5%B1%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E9%80%80%E5%87%BA%E5%BD%93%E5%89%8D%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-text">怎么清屏？怎么退出当前命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9C%89%E5%93%AA%E4%BA%9B%E5%91%BD%E4%BB%A4%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">查看文件内容有哪些命令可以使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E5%8C%85%E6%8B%AC%E5%85%B6%E5%AD%90%E6%96%87%E4%BB%B6%E5%88%B0%E8%87%AA%E5%AE%9A%E7%9B%AE%E5%BD%95"><span class="toc-text">复制文件包括其子文件到自定目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"><span class="toc-text">创建目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95%EF%BC%88%E6%AD%A4%E7%9B%AE%E5%BD%95%E6%98%AF%E7%A9%BA%E7%9B%AE%E5%BD%95%EF%BC%89"><span class="toc-text">删除目录（此目录是空目录）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%8C%85%E6%8B%AC%E5%85%B6%E5%AD%90%E6%96%87%E4%BB%B6"><span class="toc-text">删除文件包括其子文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6"><span class="toc-text">解压文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B-zip-%E6%96%87%E4%BB%B6"><span class="toc-text">解压 zip 文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-text">Redis 存储系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Redis%EF%BC%9F"><span class="toc-text">什么是 Redis？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%9A%84%E7%89%B9%E7%82%B9%E4%BB%80%E4%B9%88%E6%98%AF%EF%BC%9F"><span class="toc-text">Redis 的特点什么是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Redis 数据类型有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-text">Redis 的配置以及持久化方案有几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Redis 中的常用命令哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%B8%BB%E8%A6%81%E6%B6%88%E8%80%97%E4%BB%80%E4%B9%88%E7%89%A9%E7%90%86%E8%B5%84%E6%BA%90%EF%BC%9F"><span class="toc-text">Redis 主要消耗什么物理资源？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-text">Redis 有哪几种数据淘汰策略？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%AE%98%E6%96%B9%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8F%90%E4%BE%9B-Windows-%E7%89%88%E6%9C%AC%EF%BC%9F"><span class="toc-text">Redis 官方为什么不提供 Windows 版本？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Redis-%E9%9C%80%E8%A6%81%E6%8A%8A%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BE%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%9F"><span class="toc-text">为什么 Redis 需要把所有数据放到内存中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%82%E5%90%88%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">Redis 有哪些适合的场景？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Boot-%E6%A1%86%E6%9E%B6"><span class="toc-text">Spring Boot 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Boot%EF%BC%9F"><span class="toc-text">什么是 Spring Boot？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">Spring Boot 有哪些特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-text">Spring Boot 有哪些优点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot%E3%80%81Spring-MVC-%E5%92%8C-Spring-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Spring Boot、Spring MVC 和 Spring 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E6%98%AF%E5%93%AA%E4%B8%AA%EF%BC%9F%E5%AE%83%E4%B8%BB%E8%A6%81%E7%94%B1%E5%93%AA%E5%87%A0%E4%B8%AA%E6%B3%A8%E8%A7%A3%E7%BB%84%E6%88%90%E7%9A%84%EF%BC%9F"><span class="toc-text">Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot-%E9%9C%80%E8%A6%81%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-text">Spring Boot 需要独立的容器运行吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Spring-Boot-%E4%B8%AD%E7%9A%84-Starters%EF%BC%9F"><span class="toc-text">你如何理解 Spring Boot 中的 Starters？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-XML-%E9%85%8D%E7%BD%AE%EF%BC%9F"><span class="toc-text">Spring Boot 是否可以使用 XML 配置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bootstrap-properties-%E5%92%8C-application-properties-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">bootstrap.properties 和 application.properties 有何区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">自动装配的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD-Spring-Boot-%E4%B8%8A%E7%9A%84%E6%9B%B4%E6%94%B9%EF%BC%8C%E8%80%8C%E6%97%A0%E9%9C%80%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F"><span class="toc-text">如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AB%AF%E5%8F%A3%E4%B8%8A%E8%BF%90%E8%A1%8C-Spring-Boot-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%9F"><span class="toc-text">如何在自定义端口上运行 Spring Boot 应用程序？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringCloud"><span class="toc-text">SpringCloud</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Cloud%EF%BC%9F"><span class="toc-text">什么是 Spring Cloud？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Cloud-%E4%B8%8E-Dubbo-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Spring Cloud 与 Dubbo 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Cloud-%E6%96%AD%E8%B7%AF%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Spring Cloud 断路器的作用是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Cloud-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Spring Cloud 的核心组件有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Cloud-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%EF%BC%9F"><span class="toc-text">Spring Cloud 如何实现服务的注册？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Eureka-%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Eureka 自我保护机制是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Ribbon%EF%BC%9F"><span class="toc-text">什么是 Ribbon？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Cloud-Bus"><span class="toc-text">什么是 Spring Cloud Bus?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Eureka-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%9F"><span class="toc-text">什么是 Eureka 注册中心？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%84%8F%E4%B9%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">负载平衡的意义什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dubbo"><span class="toc-text">Dubbo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Dubbo 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%8C%E8%BF%98%E6%9C%89%E5%88%AB%E7%9A%84%E9%80%89%E6%8B%A9%E5%90%97%EF%BC%9F"><span class="toc-text">Dubbo 默认使用什么注册中心，还有别的选择吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Provider-%E4%B8%8A%E5%8F%AF%E4%BB%A5%E9%85%8D%E7%BD%AE%E7%9A%84-Consumer-%E7%AB%AF%E7%9A%84%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">在 Provider 上可以配置的 Consumer 端的属性有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Dubbo 推荐使用什么序列化框架，你知道的还有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E8%BF%98%E4%BA%86%E8%A7%A3%E5%88%AB%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E5%90%97%EF%BC%9F"><span class="toc-text">你还了解别的分布式框架吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-%E5%86%85%E7%BD%AE%E4%BA%86%E5%93%AA%E5%87%A0%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%EF%BC%9F"><span class="toc-text">Dubbo 内置了哪几种服务容器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-%E6%A0%B8%E5%BF%83%E7%9A%84%E9%85%8D%E7%BD%AE%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Dubbo 核心的配置有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99%E6%96%B9%E6%A1%88%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%98%AF%E5%93%AA%E7%A7%8D%EF%BC%9F"><span class="toc-text">Dubbo 有哪几种集群容错方案，默认是哪种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%98%AF%E5%93%AA%E7%A7%8D%EF%BC%9F"><span class="toc-text">Dubbo 有哪几种负载均衡策略，默认是哪种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">Dubbo 的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZooKeeper"><span class="toc-text">ZooKeeper</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ZooKeeper-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">ZooKeeper 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZooKeeper-%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">ZooKeeper 提供了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zookeeper-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">Zookeeper 文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9-Znode"><span class="toc-text">四种类型的数据节点 Znode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zookeeper-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-text">Zookeeper 通知机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZooKeeper-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C-Nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8C%BA%E5%88%AB"><span class="toc-text">ZooKeeper 负载均衡和 Nginx 负载均衡区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZooKeeper-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">ZooKeeper 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZooKeeper-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-text">ZooKeeper 是如何保证事务的顺序一致性的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98"><span class="toc-text">JVM 面试专题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%88%86%E5%8C%BA%EF%BC%8C%E9%9C%80%E8%A6%81%E8%AF%A6%E7%BB%86%E5%88%B0%E6%AF%8F%E4%B8%AA%E5%8C%BA%E6%94%BE%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">内存模型以及分区，需要详细到每个区放什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E9%87%8C%E9%9D%A2%E7%9A%84%E5%88%86%E5%8C%BA%EF%BC%9AEden%EF%BC%8Csurvival-%EF%BC%88from-to%EF%BC%89%EF%BC%8C%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E7%89%B9%E7%82%B9%E3%80%82"><span class="toc-text">堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%88%A4%E5%AE%9A%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">GC 的两种判定方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-%E7%9A%84%E4%B8%89%E7%A7%8D%E6%94%B6%E9%9B%86%E6%96%B9%E6%B3%95%EF%BC%9A%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E3%80%81%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E3%80%81%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E7%89%B9%E7%82%B9%EF%BC%8C%E5%88%86%E5%88%AB%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E4%BC%98%E5%8C%96%E6%94%B6%E9%9B%86%E6%96%B9%E6%B3%95%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E6%80%9D%E8%B7%AF%EF%BC%9F"><span class="toc-text">GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FCMS-%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E-G1-%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9%E3%80%82"><span class="toc-text">GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minor-GC-%E4%B8%8E-Full-GC-%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9F%EF%BC%9F"><span class="toc-text">Minor GC 与 Full GC 分别在什么时候发生？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0-Java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">简述 Java 垃圾回收机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Java 中垃圾收集的方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0-Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">简述 Java 类加载机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">什么是类加载器，类加载器有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%9F"><span class="toc-text">说一下 JVM 调优的工具？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%8F%82%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">常用的 JVM 调优的参数都有哪些？</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By SnowIce</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>